{
  "id": 0,
  "course": "/math/logic",
  "title": "Propositional tautologies",
  "difficulty": "Easy",
  "video_id": "y3svPgyGnLc",
  "accepted": 0,
  "submitted": 0,
  "description_text": "This is task to prove, using <b>LEAN 4</b> language. <br> Proofs should be done, by writing constructive <b>proof terms with the help of propositional constructors and destructors</b>. <br> In each math problem you will be given a list of permitted constructors, destructors and theorems <br> To proof each theorem, remove <b>\"sorry\"</b> and replace it with <b>proof term</b>. <br> <br> You can use following constructors and destructors <br><br><i>Constructor and destructor for conjunction:</i><br><i>Constructor: </i> <b>And.intro (h : p) (h : q) </b> creates <b>p ∧ q</b> proposition from <b>p</b> and <b>q</b> propositions</br><i>Destructor-a: </i> <b> And.left </b> creates <b>p</b> proposition from <b>p ∧ q</b> <br><i>Destructor-b: </i> <b> And.right </b> creates <b>q</b> proposition from <b>p ∧ q</b> <br><br><i>Constructor and destructor for disjunction:</i><br><i>Constructor-a: </i> <b> Or.intro_left (q : Prop) (h : p) </b> creates <b>p ∨ q</b> proposition from <b>p</b> proposition<br><i>Constructor-b: </i> <b> Or.intro_left (q : Prop) (h : p) </b> creates <b>p ∨ q</b> proposition from <b>p</b> proposition<br><i>Destructor:</i> <b> Or.elim (hpq : p ∨ q) (hpr : p → r) (hqr : q → r)</b> creates <b>r</b> proposition from <b>p ∨ q</b>, <b>p → r</b>, <b>q → r</b> propositions<br><br><i>Constructor and destructor for implication:</i> <br><i>Constructor: </i> <b>fun (hp : p) => (hq : q)</b> creates <b>p → q</b> proposition from <b>q</b> proposition</br><i>Destructor: </i> <b>(hpq : p → q) (hp : p) </b> creates <b>q</b> proposition from <b>p → q</b> and <b>p</b> propositions <br><br><i>Constructor and destructor for negation, constructor and destructor for False:</i><br><i>Constructor for negation:</i> <b>fun (hp : p) => (h : False)</b> creates <b>¬p</b> from <b>p</b><br><i>Destructor for negation/Constructor for False: </i> <b> (hnp : ¬p) (hp : p)</b> creates <b>False</b> proposition from <b>¬p</b> and <b>p</b> propositions<br><i>Destructor for False:</i><b>False.elim (h : False)</b> creates any proposition <b>p</b> from <b>False</b> proposition<br><br><i>Constructor for True:</i> <b>True.intro</b> creates True propistion<br><br><i>Constructor for Logical equivalence:</i> <b>Iff.intro (hpq : p → q) (hqp : q → p) </b> creates <b>p ↔ q</b> proposition from <b>p → q</b> and <b>q → p</b> propositions<br><i>Destructor-a for Logical equivalence:</i> <b>Iff.mp (hpq : p ↔ q)</b> creates <b>p → q</b> proposition from <b>p ↔ q</b> proposition<br><i>Destructor-b for Logical equivalence:</i> <b>Iff.mp (hpq : p ↔ q)</b> creates <b>q → p</b> proposition from <b>p ↔ q</b> proposition<br><br><i>Classical logic negation destructor:</i> <b>ByContradiction (hnnp : ¬¬p)</b> creates <b>p</b> proposition from <b>¬¬p</b> proposition",
  "examples": [],
  "constraints": [],
  "note": "Note that you can only use <b>ByContradiction</b> for the theorems, defined after <i>open Classical</i>. It is allowed to use <b>ByContradiction</b> for <i>negation_not_equiv</i>. However try not to use it.  <br> <br> For reference, see this documentation: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/title_page.html\">LEAN 4 proving</a>",
  "languages": [
    [
      "LEAN",
      "lean"
    ]
  ],
  "initial_codes": {
    "lean": "--your proof goes here\n\ntheorem neg_true : ¬ True ↔ False := sorry\n\ntheorem neg_false : ¬ False ↔ True := sorry\n\ntheorem conj_true (p : Prop) : p ∧ True ↔ p := sorry\n\ntheorem conj_false (p : Prop) : p ∧ False ↔ False := sorry\n\ntheorem disj_true (p : Prop) : p ∨ True ↔ True := sorry\n\ntheorem disj_false (p : Prop) : p ∨ False ↔ p := sorry\n\ntheorem impl_true (p : Prop) : p → True ↔ True := sorry\n\ntheorem true_impl (p : Prop) : True → p ↔ p := sorry\n\ntheorem impl_false (p : Prop) : p → False ↔ ¬ p := sorry\n\ntheorem false_impl (p : Prop) : False → p ↔ True := sorry\n\ntheorem axiomatic_rule (p : Prop) : p → p := sorry\n\ntheorem trivial_equivalence (p : Prop) : p ↔ p := sorry\n\ntheorem conj_idemp (p : Prop) : p ↔ p ∧ p := sorry\n\ntheorem disj_idemp (p : Prop) : p ↔ p ∨ p := sorry\n\ntheorem conj_comm (p q : Prop) : (p ∧ q) ↔ (q ∧ p) := sorry\n\ntheorem disj_comm (p q : Prop) : (p ∨ q) ↔ (q ∨ p) := sorry\n\ntheorem impl_comm (p q : Prop) : (p ↔ q) ↔ (q ↔ p) := sorry\n\ntheorem conj_assoc (p q r : Prop) : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry\n\ntheorem disj_assoc (p q r : Prop) : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry\n\ntheorem conj_disj_distrib (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry\n\ntheorem disj_conj_distrib (p q r : Prop) : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry\n\ntheorem morgan_disj (p q : Prop) :  ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry\n\ntheorem morgan_conj_mpr (p q : Prop) : ¬p ∨ ¬q → ¬(p ∧ q) := sorry\n\ntheorem impl_def_mpr (p q : Prop) : (¬p ∨ q) → (p → q) := sorry\n\ntheorem neg_imp_def_mpr (p q : Prop) : p ∧ ¬q → ¬(p → q) := sorry\n\ntheorem neg_to_impl (p q : Prop) : ¬p → (p → q) := sorry\n\ntheorem contraposition_mp (p q : Prop) : (p → q) → (¬q → ¬p) := sorry\n\ntheorem exportation_law (p q r : Prop) : (p → (q → r)) ↔ (p ∧ q → r) := sorry\n\ntheorem cases_impl_left (p q r : Prop) : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry\n\ntheorem syllogism (p q r : Prop) : (p → q) → (q → r) → (p → r) := sorry\n\ntheorem neg_congr (p q : Prop) : (p ↔ q) → (¬p ↔ ¬q) := sorry\n\ntheorem disj_congr (p q r : Prop) : (p ↔ q) → ((p ∨ r) ↔ (q ∨ r)) := sorry\n\ntheorem conj_congr (p q r : Prop) : (p ↔ q) → ((p ∧ r) ↔ (q ∧ r)) := sorry\n\ntheorem impl_congr_right (p q r : Prop) : (p ↔ q) → ((p → r) ↔ (q → r)) := sorry\n\ntheorem impl_congr_left (p q r : Prop) : (p ↔ q) → ((r → p) ↔ (r → q)) := sorry\n\ntheorem iff_congr_ (p q r : Prop) : (p ↔ q) → ((p ↔ r) ↔ (q ↔ r)) := sorry\n\ntheorem iff_conj_intro(p q r : Prop) : (p ↔ q) → (p ↔ r) → (p ↔ (q ∧ r)) := sorry\n\ntheorem iff_transitivity (p q r : Prop) : (p ↔ q) → (q ↔ r) → (p ↔ r) := sorry\n\ntheorem no_contradiction (p : Prop) : ¬ (p ∧ ¬ p) := sorry\n\ntheorem double_negation_mp (p : Prop) : p → ¬¬ p := sorry\n\ntheorem negation_not_equiv (p : Prop) : ¬(p ↔ ¬p) := sorry\n\nopen Classical\n\ntheorem double_negation (p : Prop) : p ↔ ¬¬p := sorry\n\ntheorem tnd (p : Prop) : p ∨ ¬ p := sorry\n\ntheorem cases_analysis (p q : Prop) : (p → q) → (¬p → q) → q := sorry\n\ntheorem cases_impl_right (p q r : Prop) : (p → q ∨ r) → ((p → q) ∨ (p → r)) := sorry\n\ntheorem Morgan_disj (p q : Prop) : ¬ (p ∧ q) ↔ ¬p ∨ ¬q := sorry\n\ntheorem neg_imp_def (p q : Prop) :  ¬ (p → q) ↔ p ∧ ¬ q := sorry\n\ntheorem imp_def (p q : Prop) : (p → q) ↔ (¬p ∨ q) := sorry\n\ntheorem contraposition (p q : Prop) : (p → q) ↔ (¬q → ¬p) := sorry\n\ntheorem peirce (p q : Prop) : (((p → q) → p) → p) := sorry"
  },
  "initial_language": "lean",
  "requirements": [
    "theorem neg_true : ¬ True ↔ False",
    "theorem neg_false : ¬ False ↔ True",
    "theorem conj_true (p : Prop) : p ∧ True ↔ p",
    "theorem conj_false (p : Prop) : p ∧ False ↔ False",
    "theorem disj_true (p : Prop) : p ∨ True ↔ True",
    "theorem disj_false (p : Prop) : p ∨ False ↔ p",
    "theorem impl_true (p : Prop) : p → True ↔ True",
    "theorem true_impl (p : Prop) : True → p ↔ p",
    "theorem impl_false (p : Prop) : p → False ↔ ¬ p",
    "theorem false_impl (p : Prop) : False → p ↔ True",
    "theorem axiomatic_rule (p : Prop) : p → p",
    "theorem trivial_equivalence (p : Prop) : p ↔ p",
    "theorem conj_idemp (p : Prop) : p ↔ p ∧ p",
    "theorem disj_idemp (p : Prop) : p ↔ p ∨ p",
    "theorem conj_comm (p q : Prop) : (p ∧ q) ↔ (q ∧ p)",
    "theorem disj_comm (p q : Prop) : (p ∨ q) ↔ (q ∨ p)",
    "theorem impl_comm (p q : Prop) : (p ↔ q) ↔ (q ↔ p)",
    "theorem conj_assoc (p q r : Prop) : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r)",
    "theorem disj_assoc (p q r : Prop) : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r)",
    "theorem conj_disj_distrib (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)",
    "theorem disj_conj_distrib (p q r : Prop) : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)",
    "theorem morgan_disj (p q : Prop) :  ¬(p ∨ q) ↔ ¬p ∧ ¬q",
    "theorem morgan_conj_mpr (p q : Prop) : ¬p ∨ ¬q → ¬(p ∧ q)",
    "theorem impl_def_mpr (p q : Prop) : (¬p ∨ q) → (p → q)",
    "theorem neg_imp_def_mpr (p q : Prop) : p ∧ ¬q → ¬(p → q)",
    "theorem neg_to_impl (p q : Prop) : ¬p → (p → q)",
    "theorem contraposition_mp (p q : Prop) : (p → q) → (¬q → ¬p)",
    "theorem exportation_law (p q r : Prop) : (p → (q → r)) ↔ (p ∧ q → r)",
    "theorem cases_impl_left (p q r : Prop) : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r)",
    "theorem syllogism (p q r : Prop) : (p → q) → (q → r) → (p → r)",
    "theorem neg_congr (p q : Prop) : (p ↔ q) → (¬p ↔ ¬q)",
    "theorem disj_congr (p q r : Prop) : (p ↔ q) → ((p ∨ r) ↔ (q ∨ r))",
    "theorem conj_congr (p q r : Prop) : (p ↔ q) → ((p ∧ r) ↔ (q ∧ r))",
    "theorem impl_congr_right (p q r : Prop) : (p ↔ q) → ((p → r) ↔ (q → r))",
    "theorem impl_congr_left (p q r : Prop) : (p ↔ q) → ((r → p) ↔ (r → q))",
    "theorem iff_congr_ (p q r : Prop) : (p ↔ q) → ((p ↔ r) ↔ (q ↔ r))",
    "theorem iff_conj_intro(p q r : Prop) : (p ↔ q) → (p ↔ r) → (p ↔ (q ∧ r))",
    "theorem iff_transitivity (p q r : Prop) : (p ↔ q) → (q ↔ r) → (p ↔ r)",
    "theorem no_contradiction (p : Prop) : ¬ (p ∧ ¬ p)",
    "theorem negation_not_equiv (p : Prop) : ¬(p ↔ ¬p)",
    "theorem double_negation_mp (p : Prop) : p → ¬¬ p",
    "theorem tnd (p : Prop) : p ∨ ¬ p",
    "theorem double_negation (p : Prop) : p ↔ ¬¬p",
    "theorem cases_analysis (p q : Prop) : (p → q) → (¬p → q) → q",
    "theorem cases_impl_right (p q r : Prop) : (p → q ∨ r) → ((p → q) ∨ (p → r))",
    "theorem Morgan_disj (p q : Prop) : ¬ (p ∧ q) ↔ ¬p ∨ ¬q",
    "theorem neg_imp_def (p q : Prop) :  ¬ (p → q) ↔ p ∧ ¬ q",
    "theorem imp_def (p q : Prop) : (p → q) ↔ (¬p ∨ q)",
    "theorem contraposition (p q : Prop) : (p → q) ↔ (¬q → ¬p)",
    "theorem peirce (p q : Prop) : (((p → q) → p) → p)"
  ]
}
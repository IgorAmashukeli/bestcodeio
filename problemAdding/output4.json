{
  "id": 0,
  "course": "/math/set",
  "title": "Zermelo Fraenkel Axioms",
  "difficulty": "Medium",
  "video_id": "y3svPgyGnLc",
  "accepted": 0,
  "submitted": 0,
  "description_text": "This is task to prove, using <b>LEAN 4</b> language. <br> Proofs should be done, by writing constructive <b>proof terms with the help of constructors and destructors</b>. <br> In each math problem you will be given a list of permitted constructors, destructors and theorems <br> To proof each theorem, remove <b>\"sorry\"</b> and replace it with <b>proof term</b>. <br> You can use following constructors and destructors: <br>In this task you allowed to use all previously discussed theorems, constructors and destructorsIn this problem we will define Set, Set constructor, ZF axioms and will construct first set-theory constructions.",
  "examples": [],
  "constraints": [],
  "note": " For reference, see this documentation: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/title_page.html\">LEAN 4 proving</a>",
  "languages": [
    [
      "LEAN",
      "lean"
    ]
  ],
  "initial_codes": {
    "lean": "-- your proof start here\n\n-- âˆƒ! notation from previous problem\n\ndef exists_unique (P : Î± â†’ Prop) : Prop := (âˆƒ (x : Î±), P x âˆ§ (âˆ€ y : Î±, (P y â†’ x = y)))\n\nopen Lean TSyntax.Compat in\n\nmacro \"âˆƒ!\" xs:explicitBinders \", \" b:term : term => expandExplicitBinders ``exists_unique xs b\n\n-- Creation of a new type: Set, it has only one predicate: membership\n\naxiom Set : Type\n\naxiom membership : Set â†’ Set â†’ Prop\n\ninfix:50 (priority := high) \" âˆˆ \" => membership\n\ninfix:50 (priority := high) \" âˆ‰ \" => (fun (x : Set) => (fun (y : Set) => Â¬ membership x y))\n\n-- main Set constructor from (Set â†’ Prop) and property of it\n\naxiom prop_to_set (P : Set â†’ Prop) (h : âˆƒ! x, P x) : Set\n\naxiom set_to_prop (P : Set â†’ Prop) (h : âˆƒ! x, P x) : P (prop_to_set P h) âˆ§ âˆ€ x, P x â†’ (x = prop_to_set P h)\n\n-- âˆ€ x âˆˆ A/âˆƒ x âˆˆ A/âˆƒ! x âˆˆ A notations\n\ndef forall_in_A (P : Set â†’ Prop) (A : Set) : Prop := (âˆ€ x, (x âˆˆ A â†’ P x))\n\ndef exists_in_A (P : Set â†’ Prop) (A : Set) : Prop := (âˆƒ x, (x âˆˆ A âˆ§ P x))\n\ndef exists_uniq_in_A (P : Set â†’ Prop) (A : Set) : Prop := (âˆƒ! x, (x âˆˆ A âˆ§ P x))\n\ndeclare_syntax_cat idents\n\nsyntax ident : idents\n\nsyntax ident idents : idents\n\nsyntax \"âˆ€\" idents \"âˆˆ\" term \";\" term : term\n\nsyntax \"âˆƒ\" idents \"âˆˆ\" term \";\" term : term\n\nsyntax \"âˆƒ!\" idents \"âˆˆ\" term \";\" term : term\n\nmacro_rules\n\n  | `(âˆ€ $idnt:ident âˆˆ $A:term; $b:term)  => `(forall_in_A (fun $idnt:ident => $b) $A)\n\n  | `(âˆ€ $idnt:ident $idnts:idents âˆˆ $A:term; $b:term) => `(forall_in_A (fun $idnt:ident => (âˆ€ $idnts:idents âˆˆ $A; $b)) $A)\n\n  | `(âˆƒ $idnt:ident âˆˆ $A:term; $b:term)  => `(exists_in_A (fun $idnt:ident => $b) $A)\n\n  | `(âˆƒ $idnt:ident $idnts:idents âˆˆ $A:term; $b:term) => `(exists_in_A (fun $idnt:ident => (âˆ€ $idnts:idents âˆˆ $A; $b)) $A)\n\n  | `(âˆƒ! $idnt:ident âˆˆ $A:term; $b:term)  => `(exists_uniq_in_A (fun $idnt:ident => $b) $A)\n\n  | `(âˆƒ! $idnt:ident $idnts:idents âˆˆ $A:term; $b:term) => `(exists_uniq_in_A (fun $idnt:ident => (âˆ€ $idnts:idents âˆˆ $A; $b)) $A)\n\n-- the problem of naive set theory\n\n-- {x | P x} may not exists\n\n-- for example {x | x âˆ‰ x} does not exist\n\ntheorem Russel_paradox : Â¬ âˆƒ A, âˆ€ x, (x âˆˆ A â†” x âˆ‰ x) := sorry\n\n-- empty and non-empty definitions\n\ndef empty (A : Set) : Prop := âˆ€ b, (b âˆ‰ A)\n\ndef non_empty (A : Set) : Prop := âˆƒ b, (b âˆˆ A)\n\n-- subset notation\n\ndef subset (A B : Set) : Prop := âˆ€ x âˆˆ A; x âˆˆ B\n\ninfix:50 (priority := high) \" âŠ† \" => subset\n\n-- subset theorems\n\ntheorem subset_refl : âˆ€ A, A âŠ† A := sorry\n\ntheorem subset_trans : âˆ€ A B C, A âŠ† B â†’ B âŠ† C â†’ A âŠ† C := sorry\n\ntheorem empty_subset_any : âˆ€ A B, empty A â†’ A âŠ† B := sorry\n\n-- set equality definition\n\ndef set_equality (A B : Set) := âˆ€ x, (x âˆˆ A â†” x âˆˆ B)\n\n-- some useful definitions before listing ZF axioms\n\ndef functional_predicate (A : Set) (P : Set â†’ Set â†’ Prop) : Prop := âˆ€ x âˆˆ A; âˆƒ! y, P x y\n\ndef is_successor (m n : Set) : Prop := âˆ€ x, (x âˆˆ n â†” x âˆˆ m âˆ¨ x = m)\n\n-- Full list of 6 Zermelo Fraenkel (ZF) axioms\n\n-- Later we will add 7th axiom: axiom of choice\n\n-- The system with this axioms will be called ZFC\n\n-- set equality implies logical equality of types\n\naxiom extensionality : âˆ€ A B, set_equality A B â†’ (A = B)\n\n-- there exists a set of all subsets of a set\n\naxiom boolean : âˆ€ A, âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âŠ† A)\n\n-- there exists a union of a set\n\naxiom union : âˆ€ A, âˆƒ B, âˆ€ x, (x âˆˆ B â†” âˆƒ y âˆˆ A; x âˆˆ y)\n\n-- there exists an infinite set with a special structure\n\naxiom infinity : âˆƒ A, (âˆƒ b, empty b âˆ§ b âˆˆ A) âˆ§ (âˆ€ x âˆˆ A; âˆ€ y, is_successor x y â†’ y âˆˆ A)\n\n-- if P is a functional 2-variable predicate for set A, then there exists an image of this predicate\n\naxiom replacement (P : Set â†’ Set â†’ Prop) : âˆ€ A, functional_predicate A P â†’ âˆƒ B, âˆ€ y, (y âˆˆ B â†” âˆƒ x âˆˆ A; P x y)\n\n-- in all non-empty set there exists a set, which elements can not be \"on the level\" of elements of A\n\naxiom regularity : âˆ€ A, non_empty A â†’ âˆƒ B âˆˆ A; âˆ€ x âˆˆ B; x âˆ‰ A\n\n-- 2 subset properties imply equality\n\ntheorem subs_subs_eq : âˆ€ A B, A âŠ† B âˆ§ B âŠ† A â†” A = B := sorry\n\n-- construction of âˆ… (empty set)\n\ntheorem exists_empty : (âˆƒ x, empty x) := sorry\n\ntheorem exists_unique_empty : (âˆƒ! x, empty x) := sorry\n\nnoncomputable def empty_set := prop_to_set empty exists_unique_empty\n\nnotation (priority := high) \"âˆ…\" => empty_set\n\n-- âˆ… properties\n\ntheorem empty_set_is_empty : empty âˆ… := sorry\n\ntheorem empty_set_subset_any : âˆ€ A, âˆ… âŠ† A := sorry\n\ntheorem non_empty_uni_then_exi (P : Set â†’ Prop) : âˆ€ A, (A â‰  âˆ…) â†’ (âˆ€ x âˆˆ A; P x) â†’ âˆƒ x âˆˆ A; P x := sorry\n\n-- construction of ğ’« A from A (boolean set)\n\ntheorem unique_boolean : (âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” x âŠ† A)) := sorry\n\nnoncomputable def boolean_func_sym : Set â†’ Set :=\n\n  fun (A : Set) => prop_to_set (fun (B : Set) => âˆ€ x, (x âˆˆ B â†” x âŠ† A)) (unique_boolean A)\n\nnotation (priority := high) \"ğ’«\" => boolean_func_sym\n\n-- ğ’« A properties\n\ntheorem boolean_set_is_boolean : âˆ€ A, (âˆ€ x, x âˆˆ ğ’« A â†” x âŠ† A) := sorry\n\ntheorem empty_elem_boolean : âˆ€ A, âˆ… âˆˆ ğ’« A := sorry\n\ntheorem boolean_set_not_empty : âˆ€ A, ğ’« A â‰  âˆ… := sorry\n\n-- construction of a set, that exists by axiom of replacement\n\ntheorem unique_replacement (P : Set â†’ Set â†’ Prop) : âˆ€ A, functional_predicate A P â†’ âˆƒ! B, âˆ€ y, (y âˆˆ B â†” âˆƒ x âˆˆ A; P x y) := sorry\n\nnoncomputable def replacement_set (P : Set â†’ Set â†’ Prop) (A : Set) (h : functional_predicate A P) : Set :=\n\n  prop_to_set (fun (B) => âˆ€ y, (y âˆˆ B â†” âˆƒ x âˆˆ A; P x y)) (unique_replacement P A h)\n\nsyntax \"RepImg\" \"[\"  term \";\"  term \";\" term \"]\"  : term\n\nmacro_rules\n\n  | `(RepImg [ $P:term ; $A:term ; $fun_rel_proof:term ])  => `(replacement_set $P $A $fun_rel_proof)\n\ntheorem replacement_set_is_replacement (p : Set â†’ Set â†’ Prop) (A : Set) (h : functional_predicate A P) : âˆ€ y, (y âˆˆ RepImg [P; A; h]) â†” âˆƒ x âˆˆ A; P x y := sorry\n\n-- construction of {aâ‚, aâ‚‚} (unordered set)\n\ntheorem exists_unordered_pair : âˆ€ aâ‚ aâ‚‚, âˆƒ C, âˆ€ x, (x âˆˆ C â†” x = aâ‚ âˆ¨ x = aâ‚‚) := sorry\n\ntheorem unique_unordered_pair : (âˆ€ aâ‚ aâ‚‚, âˆƒ! C, âˆ€ x, (x âˆˆ C â†” x = aâ‚ âˆ¨ x = aâ‚‚)) := sorry\n\nnoncomputable def unordered_pair_set : (Set â†’ Set â†’ Set) := fun (aâ‚ : Set) => fun (aâ‚‚ : Set) =>\n\n  prop_to_set (fun (B) => âˆ€ x, (x âˆˆ B â†” x = aâ‚ âˆ¨ x = aâ‚‚)) (unique_unordered_pair aâ‚ aâ‚‚)\n\nnotation (priority := high) \"{\" aâ‚ \", \" aâ‚‚ \"}\" => unordered_pair_set aâ‚ aâ‚‚\n\n-- {aâ‚, aâ‚‚} properties\n\ntheorem unordered_pair_set_is_unordered_pair : âˆ€ aâ‚ aâ‚‚ x, x âˆˆ {aâ‚, aâ‚‚} â†” x = aâ‚ âˆ¨ x = aâ‚‚ := sorry\n\ntheorem left_unordered_pair : âˆ€ aâ‚ aâ‚‚, aâ‚ âˆˆ {aâ‚, aâ‚‚} := sorry\n\ntheorem right_unordered_pair : âˆ€ aâ‚ aâ‚‚, aâ‚‚ âˆˆ {aâ‚, aâ‚‚} := sorry\n\ntheorem unordered_pair_is_unordered : âˆ€ aâ‚ aâ‚‚, {aâ‚, aâ‚‚} = {aâ‚‚, aâ‚} := sorry\n\n-- construction of {a} (singleton set)\n\nnoncomputable def singleton_set : (Set â†’ Set) := fun (a) => unordered_pair_set a a\n\nnotation (priority := high) \"{\" a \"}\" => singleton_set a\n\n-- {a} properties\n\ntheorem singleton_a_elem_is_a : âˆ€ a x, x âˆˆ {a} â†” x = a := sorry\n\ntheorem x_in_singl_x : âˆ€ x, x âˆˆ {x} := sorry\n\ntheorem singleton_non_empty : âˆ€ x, non_empty {x} := sorry\n\n-- each set is \"usual\" (does not contain itself)\n\ntheorem neg_notin_refl : âˆ€ x, x âˆ‰ x := sorry\n\n-- there is no universal set (set of all sets)\n\ntheorem no_universal_set : Â¬âˆƒ A, âˆ€ x, x âˆˆ A := sorry\n\n-- â‹ƒ A (union set) construction\n\ntheorem unique_union : âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” âˆƒ y âˆˆ A; x âˆˆ y) := sorry\n\nnoncomputable def union_set : (Set â†’ Set) := fun (A) => prop_to_set (fun (B) => âˆ€ x, (x âˆˆ B â†” âˆƒ y âˆˆ A; x âˆˆ y)) (unique_union A)\n\nnotation (priority := high) \"â‹ƒ\" => union_set\n\n-- â‹ƒ A properties\n\ntheorem union_set_is_union : (âˆ€ A x, (x âˆˆ â‹ƒ A â†” âˆƒ y âˆˆ A; x âˆˆ y)) := sorry\n\ntheorem union_singleton : âˆ€ A, â‹ƒ {A} = A := sorry\n\ntheorem union_boolean : (âˆ€ A, â‹ƒ (ğ’« A) = A) := sorry\n\ntheorem elem_subset_union : (âˆ€ A, âˆ€ x âˆˆ A; x âŠ† â‹ƒ A) := sorry\n\ntheorem boolean_union : (âˆ€ A, A âŠ† ğ’« (â‹ƒ A)) := sorry\n\ntheorem all_ss_then_union_ss : âˆ€ A B, (âˆ€ X âˆˆ A; X âŠ† B) â†’ (â‹ƒ A âŠ† B) :=sorry\n\ntheorem union_subset_monotonic : âˆ€ A B, A âŠ† B â†’ â‹ƒ A âŠ† â‹ƒ B := sorry\n\n-- {x âˆˆ A | P x} (specification set) construction\n\ntheorem specification_simple (P : Set â†’ Prop) :  (âˆ€ A, (Â¬âˆƒ x âˆˆ A; P x) â†’ âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x)) := sorry\n\ntheorem specification_hard (P : Set â†’ Prop) : (âˆ€ A, (âˆƒ x âˆˆ A; P x) â†’ âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x)) := sorry\n\ntheorem specification (P : Set â†’ Prop) : (âˆ€ A, âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x)) := sorry\n\ntheorem unique_specification (P : Set â†’ Prop) : (âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x)) := sorry\n\nnoncomputable def specification_set (P : Set â†’ Prop) : (Set â†’ Set) :=\n\n  fun (A) => prop_to_set (fun (B) => (âˆ€ x, x âˆˆ B â†” x âˆˆ A âˆ§ P x)) (unique_specification P A)\n\nsyntax \"{\" ident \"âˆˆ\" term \"|\" term \"}\" : term\n\nmacro_rules\n\n  | `({ $x:ident âˆˆ $A:term | $property:term })  => `(specification_set (fun ($x) => $property) $A)\n\n-- {x âˆˆ A | P x} properties\n\ntheorem specification_set_is_specification (P : Set â†’ Prop) : (âˆ€ A x, x âˆˆ {x âˆˆ A | P x} â†” x âˆˆ A âˆ§ P x) := sorry\n\ntheorem specification_set_subset (P : Set â†’ Prop) : (âˆ€ A, {x âˆˆ A | P x} âŠ† A) := sorry\n\n-- â‹‚ A (intersection set) construction\n\nnoncomputable def intersection_set : Set â†’ Set := fun (A) => {x âˆˆ â‹ƒ A | âˆ€ y âˆˆ A; x âˆˆ y}\n\nnotation (priority := high) \"â‹‚\" => intersection_set\n\n-- â‹‚ A properties\n\ntheorem intersection_set_is_intersection : âˆ€ A x, x âˆˆ â‹‚ A â†” (x âˆˆ â‹ƒ A âˆ§ âˆ€ y âˆˆ A; x âˆˆ y) := sorry\n\ntheorem intersection_non_empty : âˆ€ A, (A â‰  âˆ… â†’ âˆ€ x, (x âˆˆ â‹‚ A) â†” âˆ€ y âˆˆ A; x âˆˆ y) := sorry\n\ntheorem intersect_subset_monotonic : âˆ€ A B, (A â‰  âˆ…) â†’ (A âŠ† B) â†’ (â‹‚ B âŠ† â‹‚ A) := sorry"
  },
  "initial_language": "lean",
  "requirements": [
    "theorem Russel_paradox : Â¬ âˆƒ A, âˆ€ x, (x âˆˆ A â†” x âˆ‰ x)",
    "theorem subset_refl : âˆ€ A, A âŠ† A",
    "theorem subset_trans : âˆ€ A B C, A âŠ† B â†’ B âŠ† C â†’ A âŠ† C",
    "theorem empty_subset_any : âˆ€ A B, empty A â†’ A âŠ† B",
    "theorem subs_subs_eq : âˆ€ A B, A âŠ† B âˆ§ B âŠ† A â†” A = B",
    "theorem exists_empty : (âˆƒ x, empty x)",
    "theorem exists_unique_empty : (âˆƒ! x, empty x)",
    "theorem empty_set_is_empty : empty âˆ…",
    "theorem empty_set_subset_any : âˆ€ A, âˆ… âŠ† A",
    "theorem non_empty_uni_then_exi (P : Set â†’ Prop) : âˆ€ A, (A â‰  âˆ…) â†’ (âˆ€ x âˆˆ A; P x) â†’ âˆƒ x âˆˆ A; P x",
    "theorem unique_boolean : (âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” x âŠ† A))",
    "theorem boolean_set_is_boolean : âˆ€ A, (âˆ€ x, x âˆˆ ğ’« A â†” x âŠ† A)",
    "theorem empty_elem_boolean : âˆ€ A, âˆ… âˆˆ ğ’« A",
    "theorem boolean_set_not_empty : âˆ€ A, ğ’« A â‰  âˆ…",
    "theorem unique_replacement (P : Set â†’ Set â†’ Prop) : âˆ€ A, functional_predicate A P â†’ âˆƒ! B, âˆ€ y, (y âˆˆ B â†” âˆƒ x âˆˆ A; P x y)",
    "theorem replacement_set_is_replacement (p : Set â†’ Set â†’ Prop) (A : Set) (h : functional_predicate A P) : âˆ€ y, (y âˆˆ RepImg [P; A; h]) â†” âˆƒ x âˆˆ A; P x y",
    "theorem exists_unordered_pair : âˆ€ aâ‚ aâ‚‚, âˆƒ C, âˆ€ x, (x âˆˆ C â†” x = aâ‚ âˆ¨ x = aâ‚‚)",
    "theorem unique_unordered_pair : (âˆ€ aâ‚ aâ‚‚, âˆƒ! C, âˆ€ x, (x âˆˆ C â†” x = aâ‚ âˆ¨ x = aâ‚‚))",
    "theorem unordered_pair_set_is_unordered_pair : âˆ€ aâ‚ aâ‚‚ x, x âˆˆ {aâ‚, aâ‚‚} â†” x = aâ‚ âˆ¨ x = aâ‚‚",
    "theorem left_unordered_pair : âˆ€ aâ‚ aâ‚‚, aâ‚ âˆˆ {aâ‚, aâ‚‚}",
    "theorem right_unordered_pair : âˆ€ aâ‚ aâ‚‚, aâ‚‚ âˆˆ {aâ‚, aâ‚‚}",
    "theorem unordered_pair_is_unordered : âˆ€ aâ‚ aâ‚‚, {aâ‚, aâ‚‚} = {aâ‚‚, aâ‚}",
    "theorem singleton_a_elem_is_a : âˆ€ a x, x âˆˆ {a} â†” x = a",
    "theorem x_in_singl_x : âˆ€ x, x âˆˆ {x}",
    "theorem singleton_non_empty : âˆ€ x, non_empty {x}",
    "theorem neg_notin_refl : âˆ€ x, x âˆ‰ x",
    "theorem no_universal_set : Â¬âˆƒ A, âˆ€ x, x âˆˆ A",
    "theorem unique_union : âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” âˆƒ y âˆˆ A; x âˆˆ y)",
    "theorem union_set_is_union : (âˆ€ A x, (x âˆˆ â‹ƒ A â†” âˆƒ y âˆˆ A; x âˆˆ y))",
    "theorem union_singleton : âˆ€ A, â‹ƒ {A} = A",
    "theorem union_boolean : (âˆ€ A, â‹ƒ (ğ’« A) = A)",
    "theorem elem_subset_union : (âˆ€ A, âˆ€ x âˆˆ A; x âŠ† â‹ƒ A)",
    "theorem boolean_union : (âˆ€ A, A âŠ† ğ’« (â‹ƒ A))",
    "theorem all_ss_then_union_ss : âˆ€ A B, (âˆ€ X âˆˆ A; X âŠ† B) â†’ (â‹ƒ A âŠ† B)",
    "theorem union_subset_monotonic : âˆ€ A B, A âŠ† B â†’ â‹ƒ A âŠ† â‹ƒ B",
    "theorem specification_simple (P : Set â†’ Prop) :  (âˆ€ A, (Â¬âˆƒ x âˆˆ A; P x) â†’ âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x))",
    "theorem specification_hard (P : Set â†’ Prop) : (âˆ€ A, (âˆƒ x âˆˆ A; P x) â†’ âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x))",
    "theorem specification (P : Set â†’ Prop) : (âˆ€ A, âˆƒ B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x))",
    "theorem unique_specification (P : Set â†’ Prop) : (âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x))",
    "theorem specification_set_is_specification (P : Set â†’ Prop) : (âˆ€ A x, x âˆˆ {x âˆˆ A | P x} â†” x âˆˆ A âˆ§ P x)",
    "theorem specification_set_subset (P : Set â†’ Prop) : (âˆ€ A, {x âˆˆ A | P x} âŠ† A)",
    "theorem intersection_set_is_intersection : âˆ€ A x, x âˆˆ â‹‚ A â†” (x âˆˆ â‹ƒ A âˆ§ âˆ€ y âˆˆ A; x âˆˆ y)",
    "theorem intersection_non_empty : âˆ€ A, (A â‰  âˆ… â†’ âˆ€ x, (x âˆˆ â‹‚ A) â†” âˆ€ y âˆˆ A; x âˆˆ y)",
    "theorem intersect_subset_monotonic : âˆ€ A B, (A â‰  âˆ…) â†’ (A âŠ† B) â†’ (â‹‚ B âŠ† â‹‚ A)"
  ]
}
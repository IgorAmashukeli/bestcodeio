{
  "id": 0,
  "course": "/math/set",
  "title": "Zermelo Fraenkel Axioms",
  "difficulty": "Medium",
  "video_id": "y3svPgyGnLc",
  "accepted": 0,
  "submitted": 0,
  "description_text": "This is task to prove, using <b>LEAN 4</b> language. <br> Proofs should be done, by writing constructive <b>proof terms with the help of constructors and destructors</b>. <br> In each math problem you will be given a list of permitted constructors, destructors and theorems <br> To proof each theorem, remove <b>\"sorry\"</b> and replace it with <b>proof term</b>. <br> You can use following constructors and destructors: <br>In this task you allowed to use all previously discussed theorems, constructors and destructorsIn this problem we will define Set, Set constructor, ZF axioms and will construct first set-theory constructions.",
  "examples": [],
  "constraints": [],
  "note": " For reference, see this documentation: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/title_page.html\">LEAN 4 proving</a>",
  "languages": [
    [
      "LEAN",
      "lean"
    ]
  ],
  "initial_codes": {
    "lean": "-- your proof start here\n\n-- ∃! notation from previous problem\n\ndef exists_unique (P : α → Prop) : Prop := (∃ (x : α), P x ∧ (∀ y : α, (P y → x = y)))\n\nopen Lean TSyntax.Compat in\n\nmacro \"∃!\" xs:explicitBinders \", \" b:term : term => expandExplicitBinders ``exists_unique xs b\n\n-- Creation of a new type: Set, it has only one predicate: membership\n\naxiom Set : Type\n\naxiom membership : Set → Set → Prop\n\ninfix:50 (priority := high) \" ∈ \" => membership\n\ninfix:50 (priority := high) \" ∉ \" => (fun (x : Set) => (fun (y : Set) => ¬ membership x y))\n\n-- main Set constructor from (Set → Prop) and property of it\n\naxiom prop_to_set (P : Set → Prop) (h : ∃! x, P x) : Set\n\naxiom set_to_prop (P : Set → Prop) (h : ∃! x, P x) : P (prop_to_set P h) ∧ ∀ x, P x → (x = prop_to_set P h)\n\n-- ∀ x ∈ A/∃ x ∈ A/∃! x ∈ A notations\n\ndef forall_in_A (P : Set → Prop) (A : Set) : Prop := (∀ x, (x ∈ A → P x))\n\ndef exists_in_A (P : Set → Prop) (A : Set) : Prop := (∃ x, (x ∈ A ∧ P x))\n\ndef exists_uniq_in_A (P : Set → Prop) (A : Set) : Prop := (∃! x, (x ∈ A ∧ P x))\n\ndeclare_syntax_cat idents\n\nsyntax ident : idents\n\nsyntax ident idents : idents\n\nsyntax \"∀\" idents \"∈\" term \";\" term : term\n\nsyntax \"∃\" idents \"∈\" term \";\" term : term\n\nsyntax \"∃!\" idents \"∈\" term \";\" term : term\n\nmacro_rules\n\n  | `(∀ $idnt:ident ∈ $A:term; $b:term)  => `(forall_in_A (fun $idnt:ident => $b) $A)\n\n  | `(∀ $idnt:ident $idnts:idents ∈ $A:term; $b:term) => `(forall_in_A (fun $idnt:ident => (∀ $idnts:idents ∈ $A; $b)) $A)\n\n  | `(∃ $idnt:ident ∈ $A:term; $b:term)  => `(exists_in_A (fun $idnt:ident => $b) $A)\n\n  | `(∃ $idnt:ident $idnts:idents ∈ $A:term; $b:term) => `(exists_in_A (fun $idnt:ident => (∀ $idnts:idents ∈ $A; $b)) $A)\n\n  | `(∃! $idnt:ident ∈ $A:term; $b:term)  => `(exists_uniq_in_A (fun $idnt:ident => $b) $A)\n\n  | `(∃! $idnt:ident $idnts:idents ∈ $A:term; $b:term) => `(exists_uniq_in_A (fun $idnt:ident => (∀ $idnts:idents ∈ $A; $b)) $A)\n\n-- the problem of naive set theory\n\n-- {x | P x} may not exists\n\n-- for example {x | x ∉ x} does not exist\n\ntheorem Russel_paradox : ¬ ∃ A, ∀ x, (x ∈ A ↔ x ∉ x) := sorry\n\n-- empty and non-empty definitions\n\ndef empty (A : Set) : Prop := ∀ b, (b ∉ A)\n\ndef non_empty (A : Set) : Prop := ∃ b, (b ∈ A)\n\n-- subset notation\n\ndef subset (A B : Set) : Prop := ∀ x ∈ A; x ∈ B\n\ninfix:50 (priority := high) \" ⊆ \" => subset\n\n-- subset theorems\n\ntheorem subset_refl : ∀ A, A ⊆ A := sorry\n\ntheorem subset_trans : ∀ A B C, A ⊆ B → B ⊆ C → A ⊆ C := sorry\n\ntheorem empty_subset_any : ∀ A B, empty A → A ⊆ B := sorry\n\n-- set equality definition\n\ndef set_equality (A B : Set) := ∀ x, (x ∈ A ↔ x ∈ B)\n\n-- some useful definitions before listing ZF axioms\n\ndef functional_predicate (A : Set) (P : Set → Set → Prop) : Prop := ∀ x ∈ A; ∃! y, P x y\n\ndef is_successor (m n : Set) : Prop := ∀ x, (x ∈ n ↔ x ∈ m ∨ x = m)\n\n-- Full list of 6 Zermelo Fraenkel (ZF) axioms\n\n-- Later we will add 7th axiom: axiom of choice\n\n-- The system with this axioms will be called ZFC\n\n-- set equality implies logical equality of types\n\naxiom extensionality : ∀ A B, set_equality A B → (A = B)\n\n-- there exists a set of all subsets of a set\n\naxiom boolean : ∀ A, ∃ B, ∀ x, (x ∈ B ↔ x ⊆ A)\n\n-- there exists a union of a set\n\naxiom union : ∀ A, ∃ B, ∀ x, (x ∈ B ↔ ∃ y ∈ A; x ∈ y)\n\n-- there exists an infinite set with a special structure\n\naxiom infinity : ∃ A, (∃ b, empty b ∧ b ∈ A) ∧ (∀ x ∈ A; ∀ y, is_successor x y → y ∈ A)\n\n-- if P is a functional 2-variable predicate for set A, then there exists an image of this predicate\n\naxiom replacement (P : Set → Set → Prop) : ∀ A, functional_predicate A P → ∃ B, ∀ y, (y ∈ B ↔ ∃ x ∈ A; P x y)\n\n-- in all non-empty set there exists a set, which elements can not be \"on the level\" of elements of A\n\naxiom regularity : ∀ A, non_empty A → ∃ B ∈ A; ∀ x ∈ B; x ∉ A\n\n-- 2 subset properties imply equality\n\ntheorem subs_subs_eq : ∀ A B, A ⊆ B ∧ B ⊆ A ↔ A = B := sorry\n\n-- construction of ∅ (empty set)\n\ntheorem exists_empty : (∃ x, empty x) := sorry\n\ntheorem exists_unique_empty : (∃! x, empty x) := sorry\n\nnoncomputable def empty_set := prop_to_set empty exists_unique_empty\n\nnotation (priority := high) \"∅\" => empty_set\n\n-- ∅ properties\n\ntheorem empty_set_is_empty : empty ∅ := sorry\n\ntheorem empty_set_subset_any : ∀ A, ∅ ⊆ A := sorry\n\ntheorem non_empty_uni_then_exi (P : Set → Prop) : ∀ A, (A ≠ ∅) → (∀ x ∈ A; P x) → ∃ x ∈ A; P x := sorry\n\n-- construction of 𝒫 A from A (boolean set)\n\ntheorem unique_boolean : (∀ A, ∃! B, ∀ x, (x ∈ B ↔ x ⊆ A)) := sorry\n\nnoncomputable def boolean_func_sym : Set → Set :=\n\n  fun (A : Set) => prop_to_set (fun (B : Set) => ∀ x, (x ∈ B ↔ x ⊆ A)) (unique_boolean A)\n\nnotation (priority := high) \"𝒫\" => boolean_func_sym\n\n-- 𝒫 A properties\n\ntheorem boolean_set_is_boolean : ∀ A, (∀ x, x ∈ 𝒫 A ↔ x ⊆ A) := sorry\n\ntheorem empty_elem_boolean : ∀ A, ∅ ∈ 𝒫 A := sorry\n\ntheorem boolean_set_not_empty : ∀ A, 𝒫 A ≠ ∅ := sorry\n\n-- construction of a set, that exists by axiom of replacement\n\ntheorem unique_replacement (P : Set → Set → Prop) : ∀ A, functional_predicate A P → ∃! B, ∀ y, (y ∈ B ↔ ∃ x ∈ A; P x y) := sorry\n\nnoncomputable def replacement_set (P : Set → Set → Prop) (A : Set) (h : functional_predicate A P) : Set :=\n\n  prop_to_set (fun (B) => ∀ y, (y ∈ B ↔ ∃ x ∈ A; P x y)) (unique_replacement P A h)\n\nsyntax \"RepImg\" \"[\"  term \";\"  term \";\" term \"]\"  : term\n\nmacro_rules\n\n  | `(RepImg [ $P:term ; $A:term ; $fun_rel_proof:term ])  => `(replacement_set $P $A $fun_rel_proof)\n\ntheorem replacement_set_is_replacement (p : Set → Set → Prop) (A : Set) (h : functional_predicate A P) : ∀ y, (y ∈ RepImg [P; A; h]) ↔ ∃ x ∈ A; P x y := sorry\n\n-- construction of {a₁, a₂} (unordered set)\n\ntheorem exists_unordered_pair : ∀ a₁ a₂, ∃ C, ∀ x, (x ∈ C ↔ x = a₁ ∨ x = a₂) := sorry\n\ntheorem unique_unordered_pair : (∀ a₁ a₂, ∃! C, ∀ x, (x ∈ C ↔ x = a₁ ∨ x = a₂)) := sorry\n\nnoncomputable def unordered_pair_set : (Set → Set → Set) := fun (a₁ : Set) => fun (a₂ : Set) =>\n\n  prop_to_set (fun (B) => ∀ x, (x ∈ B ↔ x = a₁ ∨ x = a₂)) (unique_unordered_pair a₁ a₂)\n\nnotation (priority := high) \"{\" a₁ \", \" a₂ \"}\" => unordered_pair_set a₁ a₂\n\n-- {a₁, a₂} properties\n\ntheorem unordered_pair_set_is_unordered_pair : ∀ a₁ a₂ x, x ∈ {a₁, a₂} ↔ x = a₁ ∨ x = a₂ := sorry\n\ntheorem left_unordered_pair : ∀ a₁ a₂, a₁ ∈ {a₁, a₂} := sorry\n\ntheorem right_unordered_pair : ∀ a₁ a₂, a₂ ∈ {a₁, a₂} := sorry\n\ntheorem unordered_pair_is_unordered : ∀ a₁ a₂, {a₁, a₂} = {a₂, a₁} := sorry\n\n-- construction of {a} (singleton set)\n\nnoncomputable def singleton_set : (Set → Set) := fun (a) => unordered_pair_set a a\n\nnotation (priority := high) \"{\" a \"}\" => singleton_set a\n\n-- {a} properties\n\ntheorem singleton_a_elem_is_a : ∀ a x, x ∈ {a} ↔ x = a := sorry\n\ntheorem x_in_singl_x : ∀ x, x ∈ {x} := sorry\n\ntheorem singleton_non_empty : ∀ x, non_empty {x} := sorry\n\n-- each set is \"usual\" (does not contain itself)\n\ntheorem neg_notin_refl : ∀ x, x ∉ x := sorry\n\n-- there is no universal set (set of all sets)\n\ntheorem no_universal_set : ¬∃ A, ∀ x, x ∈ A := sorry\n\n-- ⋃ A (union set) construction\n\ntheorem unique_union : ∀ A, ∃! B, ∀ x, (x ∈ B ↔ ∃ y ∈ A; x ∈ y) := sorry\n\nnoncomputable def union_set : (Set → Set) := fun (A) => prop_to_set (fun (B) => ∀ x, (x ∈ B ↔ ∃ y ∈ A; x ∈ y)) (unique_union A)\n\nnotation (priority := high) \"⋃\" => union_set\n\n-- ⋃ A properties\n\ntheorem union_set_is_union : (∀ A x, (x ∈ ⋃ A ↔ ∃ y ∈ A; x ∈ y)) := sorry\n\ntheorem union_singleton : ∀ A, ⋃ {A} = A := sorry\n\ntheorem union_boolean : (∀ A, ⋃ (𝒫 A) = A) := sorry\n\ntheorem elem_subset_union : (∀ A, ∀ x ∈ A; x ⊆ ⋃ A) := sorry\n\ntheorem boolean_union : (∀ A, A ⊆ 𝒫 (⋃ A)) := sorry\n\ntheorem all_ss_then_union_ss : ∀ A B, (∀ X ∈ A; X ⊆ B) → (⋃ A ⊆ B) :=sorry\n\ntheorem union_subset_monotonic : ∀ A B, A ⊆ B → ⋃ A ⊆ ⋃ B := sorry\n\n-- {x ∈ A | P x} (specification set) construction\n\ntheorem specification_simple (P : Set → Prop) :  (∀ A, (¬∃ x ∈ A; P x) → ∃ B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x)) := sorry\n\ntheorem specification_hard (P : Set → Prop) : (∀ A, (∃ x ∈ A; P x) → ∃ B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x)) := sorry\n\ntheorem specification (P : Set → Prop) : (∀ A, ∃ B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x)) := sorry\n\ntheorem unique_specification (P : Set → Prop) : (∀ A, ∃! B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x)) := sorry\n\nnoncomputable def specification_set (P : Set → Prop) : (Set → Set) :=\n\n  fun (A) => prop_to_set (fun (B) => (∀ x, x ∈ B ↔ x ∈ A ∧ P x)) (unique_specification P A)\n\nsyntax \"{\" ident \"∈\" term \"|\" term \"}\" : term\n\nmacro_rules\n\n  | `({ $x:ident ∈ $A:term | $property:term })  => `(specification_set (fun ($x) => $property) $A)\n\n-- {x ∈ A | P x} properties\n\ntheorem specification_set_is_specification (P : Set → Prop) : (∀ A x, x ∈ {x ∈ A | P x} ↔ x ∈ A ∧ P x) := sorry\n\ntheorem specification_set_subset (P : Set → Prop) : (∀ A, {x ∈ A | P x} ⊆ A) := sorry\n\n-- ⋂ A (intersection set) construction\n\nnoncomputable def intersection_set : Set → Set := fun (A) => {x ∈ ⋃ A | ∀ y ∈ A; x ∈ y}\n\nnotation (priority := high) \"⋂\" => intersection_set\n\n-- ⋂ A properties\n\ntheorem intersection_set_is_intersection : ∀ A x, x ∈ ⋂ A ↔ (x ∈ ⋃ A ∧ ∀ y ∈ A; x ∈ y) := sorry\n\ntheorem intersection_non_empty : ∀ A, (A ≠ ∅ → ∀ x, (x ∈ ⋂ A) ↔ ∀ y ∈ A; x ∈ y) := sorry\n\ntheorem intersect_subset_monotonic : ∀ A B, (A ≠ ∅) → (A ⊆ B) → (⋂ B ⊆ ⋂ A) := sorry"
  },
  "initial_language": "lean",
  "requirements": [
    "theorem Russel_paradox : ¬ ∃ A, ∀ x, (x ∈ A ↔ x ∉ x)",
    "theorem subset_refl : ∀ A, A ⊆ A",
    "theorem subset_trans : ∀ A B C, A ⊆ B → B ⊆ C → A ⊆ C",
    "theorem empty_subset_any : ∀ A B, empty A → A ⊆ B",
    "theorem subs_subs_eq : ∀ A B, A ⊆ B ∧ B ⊆ A ↔ A = B",
    "theorem exists_empty : (∃ x, empty x)",
    "theorem exists_unique_empty : (∃! x, empty x)",
    "theorem empty_set_is_empty : empty ∅",
    "theorem empty_set_subset_any : ∀ A, ∅ ⊆ A",
    "theorem non_empty_uni_then_exi (P : Set → Prop) : ∀ A, (A ≠ ∅) → (∀ x ∈ A; P x) → ∃ x ∈ A; P x",
    "theorem unique_boolean : (∀ A, ∃! B, ∀ x, (x ∈ B ↔ x ⊆ A))",
    "theorem boolean_set_is_boolean : ∀ A, (∀ x, x ∈ 𝒫 A ↔ x ⊆ A)",
    "theorem empty_elem_boolean : ∀ A, ∅ ∈ 𝒫 A",
    "theorem boolean_set_not_empty : ∀ A, 𝒫 A ≠ ∅",
    "theorem unique_replacement (P : Set → Set → Prop) : ∀ A, functional_predicate A P → ∃! B, ∀ y, (y ∈ B ↔ ∃ x ∈ A; P x y)",
    "theorem replacement_set_is_replacement (p : Set → Set → Prop) (A : Set) (h : functional_predicate A P) : ∀ y, (y ∈ RepImg [P; A; h]) ↔ ∃ x ∈ A; P x y",
    "theorem exists_unordered_pair : ∀ a₁ a₂, ∃ C, ∀ x, (x ∈ C ↔ x = a₁ ∨ x = a₂)",
    "theorem unique_unordered_pair : (∀ a₁ a₂, ∃! C, ∀ x, (x ∈ C ↔ x = a₁ ∨ x = a₂))",
    "theorem unordered_pair_set_is_unordered_pair : ∀ a₁ a₂ x, x ∈ {a₁, a₂} ↔ x = a₁ ∨ x = a₂",
    "theorem left_unordered_pair : ∀ a₁ a₂, a₁ ∈ {a₁, a₂}",
    "theorem right_unordered_pair : ∀ a₁ a₂, a₂ ∈ {a₁, a₂}",
    "theorem unordered_pair_is_unordered : ∀ a₁ a₂, {a₁, a₂} = {a₂, a₁}",
    "theorem singleton_a_elem_is_a : ∀ a x, x ∈ {a} ↔ x = a",
    "theorem x_in_singl_x : ∀ x, x ∈ {x}",
    "theorem singleton_non_empty : ∀ x, non_empty {x}",
    "theorem neg_notin_refl : ∀ x, x ∉ x",
    "theorem no_universal_set : ¬∃ A, ∀ x, x ∈ A",
    "theorem unique_union : ∀ A, ∃! B, ∀ x, (x ∈ B ↔ ∃ y ∈ A; x ∈ y)",
    "theorem union_set_is_union : (∀ A x, (x ∈ ⋃ A ↔ ∃ y ∈ A; x ∈ y))",
    "theorem union_singleton : ∀ A, ⋃ {A} = A",
    "theorem union_boolean : (∀ A, ⋃ (𝒫 A) = A)",
    "theorem elem_subset_union : (∀ A, ∀ x ∈ A; x ⊆ ⋃ A)",
    "theorem boolean_union : (∀ A, A ⊆ 𝒫 (⋃ A))",
    "theorem all_ss_then_union_ss : ∀ A B, (∀ X ∈ A; X ⊆ B) → (⋃ A ⊆ B)",
    "theorem union_subset_monotonic : ∀ A B, A ⊆ B → ⋃ A ⊆ ⋃ B",
    "theorem specification_simple (P : Set → Prop) :  (∀ A, (¬∃ x ∈ A; P x) → ∃ B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x))",
    "theorem specification_hard (P : Set → Prop) : (∀ A, (∃ x ∈ A; P x) → ∃ B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x))",
    "theorem specification (P : Set → Prop) : (∀ A, ∃ B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x))",
    "theorem unique_specification (P : Set → Prop) : (∀ A, ∃! B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x))",
    "theorem specification_set_is_specification (P : Set → Prop) : (∀ A x, x ∈ {x ∈ A | P x} ↔ x ∈ A ∧ P x)",
    "theorem specification_set_subset (P : Set → Prop) : (∀ A, {x ∈ A | P x} ⊆ A)",
    "theorem intersection_set_is_intersection : ∀ A x, x ∈ ⋂ A ↔ (x ∈ ⋃ A ∧ ∀ y ∈ A; x ∈ y)",
    "theorem intersection_non_empty : ∀ A, (A ≠ ∅ → ∀ x, (x ∈ ⋂ A) ↔ ∀ y ∈ A; x ∈ y)",
    "theorem intersect_subset_monotonic : ∀ A B, (A ≠ ∅) → (A ⊆ B) → (⋂ B ⊆ ⋂ A)"
  ]
}
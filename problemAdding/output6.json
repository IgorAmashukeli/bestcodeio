{
  "id": 2,
  "course": "/math/set",
  "title": "Binary relations",
  "difficulty": "Easy",
  "video_id": "y3svPgyGnLc",
  "accepted": 0,
  "submitted": 0,
  "description_text": "This is task to prove, using <b>LEAN 4</b> language. <br> Proofs should be done, by writing constructive <b>proof terms with the help of constructors and destructors</b>. <br> In each math problem you will be given a list of permitted constructors, destructors and theorems <br> To proof each theorem, remove <b>\"sorry\"</b> and replace it with <b>proof term</b>. <br> You can use following constructors and destructors: <br>In this task you allowed to use all previously discussed theorems, constructors and destructors<br>In this problem we will ordered pairs, cartesian products, binary relations, domain, range, inverse, composition, image, preimage and will prove theorems about them",
  "examples": [],
  "constraints": [],
  "note": " For reference, see this documentation: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/title_page.html\">LEAN 4 proving</a>",
  "languages": [
    [
      "LEAN",
      "lean"
    ]
  ],
  "initial_codes": {
    "lean": "-- previous problem defitions\n\ndef exists_unique (P : Î± â†’ Prop) : Prop := (âˆƒ (x : Î±), P x âˆ§ (âˆ€ y : Î±, (P y â†’ x = y)))\n\nopen Lean TSyntax.Compat in\n\nmacro \"âˆƒ!\" xs:explicitBinders \", \" b:term : term => expandExplicitBinders ``exists_unique xs b\n\naxiom Set : Type\n\naxiom membership : Set â†’ Set â†’ Prop\n\ninfix:50 (priority := high) \" âˆˆ \" => membership\n\ninfix:50 (priority := high) \" âˆ‰ \" => (fun (x : Set) => (fun (y : Set) => Â¬ membership x y))\n\naxiom prop_to_set (P : Set â†’ Prop) (h : âˆƒ! x, P x) : Set\n\naxiom set_to_prop (P : Set â†’ Prop) (h : âˆƒ! x, P x) : P (prop_to_set P h) âˆ§ âˆ€ x, x â‰  prop_to_set P h â†’ Â¬P x\n\ndef forall_in_A (P : Set â†’ Prop) (A : Set) : Prop := (âˆ€ x, (x âˆˆ A â†’ P x))\n\ndef exists_in_A (P : Set â†’ Prop) (A : Set) : Prop := (âˆƒ x, (x âˆˆ A âˆ§ P x))\n\ndef exists_uniq_in_A (P : Set â†’ Prop) (A : Set) : Prop := (âˆƒ! x, (x âˆˆ A âˆ§ P x))\n\ndeclare_syntax_cat idents\n\nsyntax ident : idents\n\nsyntax ident idents : idents\n\nsyntax \"âˆ€\" idents \"âˆˆ\" term \";\" term : term\n\nsyntax \"âˆƒ\" idents \"âˆˆ\" term \";\" term : term\n\nsyntax \"âˆƒ!\" idents \"âˆˆ\" term \";\" term : term\n\nmacro_rules\n\n  | `(âˆ€ $idnt:ident âˆˆ $A:term; $b:term)  => `(forall_in_A (fun $idnt:ident => $b) $A)\n\n  | `(âˆ€ $idnt:ident $idnts:idents âˆˆ $A:term; $b:term) => `(forall_in_A (fun $idnt:ident => (âˆ€ $idnts:idents âˆˆ $A; $b)) $A)\n\n  | `(âˆƒ $idnt:ident âˆˆ $A:term; $b:term)  => `(exists_in_A (fun $idnt:ident => $b) $A)\n\n  | `(âˆƒ $idnt:ident $idnts:idents âˆˆ $A:term; $b:term) => `(exists_in_A (fun $idnt:ident => (âˆ€ $idnts:idents âˆˆ $A; $b)) $A)\n\n  | `(âˆƒ! $idnt:ident âˆˆ $A:term; $b:term)  => `(exists_uniq_in_A (fun $idnt:ident => $b) $A)\n\n  | `(âˆƒ! $idnt:ident $idnts:idents âˆˆ $A:term; $b:term) => `(exists_uniq_in_A (fun $idnt:ident => (âˆ€ $idnts:idents âˆˆ $A; $b)) $A)\n\ndef empty (A : Set) : Prop := âˆ€ b, (b âˆ‰ A)\n\ndef non_empty (A : Set) : Prop := âˆƒ b, (b âˆˆ A)\n\ndef subset (A B : Set) : Prop := âˆ€ x âˆˆ A; x âˆˆ B\n\ndef is_successor (m n : Set) : Prop := âˆ€ x, (x âˆˆ n â†” x âˆˆ m âˆ¨ x = m)\n\ninfix:50 (priority := high) \" âŠ† \" => subset\n\naxiom exists_unique_empty : (âˆƒ! x, empty x)\n\naxiom unique_unordered_pair : (âˆ€ aâ‚ aâ‚‚, âˆƒ! C, âˆ€ x, (x âˆˆ C â†” x = aâ‚ âˆ¨ x = aâ‚‚))\n\naxiom unique_union : âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” âˆƒ y âˆˆ A; x âˆˆ y)\n\naxiom unique_specification (P : Set â†’ Prop) : (âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” x âˆˆ A âˆ§ P x))\n\naxiom unique_boolean : (âˆ€ A, âˆƒ! B, âˆ€ x, (x âˆˆ B â†” x âŠ† A))\n\nnoncomputable def empty_set := prop_to_set empty exists_unique_empty\n\nnoncomputable def unordered_pair_set : (Set â†’ Set â†’ Set) := fun (aâ‚ : Set) => fun (aâ‚‚ : Set) =>\n\n  prop_to_set (fun (B) => âˆ€ x, (x âˆˆ B â†” x = aâ‚ âˆ¨ x = aâ‚‚)) (unique_unordered_pair aâ‚ aâ‚‚)\n\nnoncomputable def singleton_set : (Set â†’ Set) := fun (a) => unordered_pair_set a a\n\nnoncomputable def union_set : (Set â†’ Set) := fun (A) => prop_to_set (fun (B) => âˆ€ x, (x âˆˆ B â†” âˆƒ y âˆˆ A; x âˆˆ y)) (unique_union A)\n\nnoncomputable def specification_set (P : Set â†’ Prop) : (Set â†’ Set) :=\n\n  fun (A) => prop_to_set (fun (B) => (âˆ€ x, x âˆˆ B â†” x âˆˆ A âˆ§ P x)) (unique_specification P A)\n\nnotation (priority := high) \"âˆ…\" => empty_set\n\nnotation (priority := high) \"{\" aâ‚ \", \" aâ‚‚ \"}\" => unordered_pair_set aâ‚ aâ‚‚\n\nnotation (priority := high) \"{\" a \"}\" => singleton_set a\n\nnotation (priority := high) \"â‹ƒ\" => union_set\n\nsyntax \"{\" ident \"âˆˆ\" term \"|\" term \"}\" : term\n\nmacro_rules\n\n  | `({ $x:ident âˆˆ $A:term | $property:term })  => `(specification_set (fun ($x) => $property) $A)\n\nnoncomputable def union_2sets (A B : Set) := â‹ƒ {A, B}\n\ninfix:60 (priority:=high) \" âˆª \" => union_2sets\n\nnoncomputable def intersect_2sets (A B : Set) := {x âˆˆ A | x âˆˆ B}\n\ninfix:60 (priority:=high) \" âˆ© \" => intersect_2sets\n\nnoncomputable def difference (A B : Set) := {x âˆˆ A | x âˆ‰ B}\n\ninfix:60 (priority:=high) \" \\\\ \" => difference\n\nnoncomputable def symmetric_difference (A B : Set) := (A \\ B) âˆª (B \\ A)\n\ninfix:60 (priority:=high) \" â–³ \" => symmetric_difference\n\nnoncomputable def intersection_set : Set â†’ Set := fun (A) => {x âˆˆ â‹ƒ A | âˆ€ y âˆˆ A; x âˆˆ y}\n\nnotation (priority := high) \"â‹‚\" => intersection_set\n\ndeclare_syntax_cat set_comprehension\n\nsyntax term \"; \" set_comprehension : set_comprehension\n\nsyntax term : set_comprehension\n\nsyntax \"{\" set_comprehension \"}\" : term\n\nmacro_rules\n\n| `({$term1:term; $term2:term}) => `(unordered_pair_set $term1:term $term2:term)\n\n| `({$elem:term; $rest:set_comprehension}) => `({$rest:set_comprehension} âˆª {$elem:term})\n\nnoncomputable def boolean_func_sym : Set â†’ Set :=\n\n  fun (A : Set) => prop_to_set (fun (B : Set) => âˆ€ x, (x âˆˆ B â†” x âŠ† A)) (unique_boolean A)\n\nnotation (priority := high) \"ğ’«\" => boolean_func_sym\n\n-- (aâ‚, aâ‚‚) (ordered pair) construction\n\nnoncomputable def ordered_pair_set (a b : Set) := {{a}, {a, b}}\n\nnotation (priority := high) \"(\" aâ‚ \", \" aâ‚‚ \")\" => ordered_pair_set aâ‚ aâ‚‚\n\n-- ordered pair main property\n\ntheorem ordered_pair_set_prop : âˆ€ a b c d, (a, b) = (c, d) â†” (a = c âˆ§ b = d) := sorry\n\n-- set, where ordered pair \"lives\"\n\ntheorem ordered_pair_set_belonging: âˆ€ A B, âˆ€ a âˆˆ A; âˆ€ b âˆˆ B; (a, b) âˆˆ ğ’« (ğ’« (A âˆª B)) := sorry\n\n-- interesting ways to deconstruct ordered pairs\n\ntheorem inter_pair_is_singl_fst : âˆ€ a b, â‹‚ (a, b) = {a} := sorry\n\ntheorem union_pair_is_all_coords : âˆ€ a b, â‹ƒ (a, b) = {a, b} := sorry\n\ntheorem coordinates_snd_corr_lemma : âˆ€ a b, {x âˆˆ â‹ƒ (a, b) | â‹ƒ (a, b) â‰  â‹‚ (a, b) â†’ x âˆ‰ â‹‚ (a, b)} = {b} := sorry\n\n-- first coordinate and second coordinate projectors\n\nnoncomputable def fst_coor (A : Set) : Set := â‹ƒ (â‹‚ A)\n\nnoncomputable def snd_coor (A : Set) : Set := â‹ƒ ({x âˆˆ â‹ƒ A | â‹ƒ A â‰  â‹‚ A â†’ x âˆ‰ â‹‚ A})\n\n-- ordered pair projectors main property\n\ntheorem coordinates_fst_coor : âˆ€ a b, fst_coor (a, b) = a := sorry\n\ntheorem coordinates_snd_copr : âˆ€ a b, snd_coor (a, b) = b := sorry\n\n-- A Ã— B (cartesian product) construction\n\nnoncomputable def cartesian_product (A : Set) (B : Set) : Set := {z âˆˆ ğ’« (ğ’« (A âˆª B)) | âˆƒ x âˆˆ A; âˆƒ y âˆˆ B; z = (x, y)}\n\ninfix:60 (priority:=high) \" Ã— \" => cartesian_product\n\n-- cartesian product main property\n\ntheorem cartesian_product_is_cartesian: âˆ€ A B pr, pr âˆˆ (A Ã— B) â†” (âˆƒ x âˆˆ A; âˆƒ y âˆˆ B; pr = (x, y)) := sorry\n\n-- cartesian product main property in terms of ordered pairs\n\ntheorem cartesian_product_pair_prop : âˆ€ A B a b, (a, b) âˆˆ (A Ã— B) â†” (a âˆˆ A âˆ§ b âˆˆ B) := sorry\n\n-- tuple construction\n\n-- â…aâ†, â…a, bâ†, â…a, b, câ†, â…a, b, c, dâ†, ...\n\ndeclare_syntax_cat pair_comprehension\n\nsyntax  pair_comprehension \"; \" term : pair_comprehension\n\nsyntax term : pair_comprehension\n\nsyntax \"â…\" pair_comprehension \"â†\" : term\n\nmacro_rules\n\n| `(â… $term1:termâ†) => `($term1)\n\n| `(â… $term1:term; $term2:termâ†) => `(ordered_pair_set $term1 $term2)\n\n| `(â… $rest:pair_comprehension; $elem:termâ†) => `(ordered_pair_set â…$rest:pair_comprehensionâ† $elem:term)\n\n-- binary relation property\n\nnoncomputable def binary_relation (R : Set) : Prop := âˆ€ z âˆˆ R; âˆƒ a, âˆƒ b, z = (a, b)\n\n-- write (x . P . y) istead of (x, y) âˆˆ P\n\nmacro_rules\n\n| `(($x:term . $P:term . $y:term)) => `(($x, $y) âˆˆ $P)\n\n-- set, where first and second coordinates of pairs in binary relation \"live\"\n\ntheorem binary_relation_elements_set: âˆ€ R x y, (x . R . y) â†’ (x âˆˆ â‹ƒ (â‹ƒ R) âˆ§ y âˆˆ â‹ƒ (â‹ƒ R)) := sorry\n\n-- domain and range of binary relation\n\nnoncomputable def dom (R : Set) := {x âˆˆ â‹ƒ (â‹ƒ R) | âˆƒ y, (x . R . y)}\n\nnoncomputable def rng (R : Set) := {y âˆˆ â‹ƒ (â‹ƒ R) | âˆƒ x, (x . R . y)}\n\n-- for binary relation R, U (U R) is actually domain âˆª range\n\ntheorem dom_rng_rel_prop: âˆ€ R, (binary_relation R) â†’ (dom R âˆª rng R = â‹ƒ (â‹ƒ R)) := sorry\n\n-- main domain property\n\ntheorem dom_prop : âˆ€ R x, x âˆˆ dom R â†” âˆƒ y, (x . R . y) := sorry\n\n-- main range property\n\ntheorem rng_prop : âˆ€ R y, y âˆˆ rng R â†” âˆƒ x, (x . R . y) := sorry\n\n-- each binary relation is a subset of domain Ã— range.\n\ntheorem binary_relation_prop : âˆ€ R, binary_relation R â†’ R âŠ† dom R Ã— rng R := sorry\n\n-- each subset of cartesian product is binary relation with domain and range properties\n\ntheorem prop_then_binary_relation : âˆ€ A B R, R âŠ† A Ã— B â†’ binary_relation R âˆ§ dom R âŠ† A âˆ§ rng R âŠ† B := sorry\n\n-- another domain and range property\n\ntheorem rel_dom_rng_elem : âˆ€ R, binary_relation R â†’ âˆ€ x y, (x . R . y) â†’ x âˆˆ dom R âˆ§ y âˆˆ rng R := sorry\n\n-- union and intersection of binary relation is binary relation\n\ntheorem union2_rel_is_rel : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ binary_relation (P âˆª Q) := sorry\n\ntheorem intersect2_rel_is_rel : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ binary_relation (P âˆ© Q) := sorry\n\n-- binary relation, implemented as a cartesian product subset\n\nnoncomputable def binary_relation_between (A B R : Set) : Prop := R âŠ† A Ã— B\n\nnoncomputable def binary_relation_on (A R : Set) : Prop := R âŠ† A Ã— A\n\n-- cartesian complement of any set is a binary relation\n\nnoncomputable def comp (A B R : Set) : Set := (A Ã— B) \\ R\n\ntheorem comp_is_rel : âˆ€ A B R, binary_relation (comp A B R) := sorry\n\n-- property, enough for subset of binary relation\n\ntheorem rel_subset : (âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (âˆ€ x y, (x . P . y) â†’ (x . Q . y)) â†’ P âŠ† Q) := sorry\n\n-- property, enough for equality of binary relation\n\ntheorem relation_equality : (âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ ((âˆ€ x y, (x . P . y) â†” (x . Q . y)) â†’ P = Q)) := sorry\n\n-- Râ»Â¹ (inverse binary relation) construction\n\nnoncomputable def inv (R : Set) : Set := {z âˆˆ rng R Ã— dom R | âˆƒ x, âˆƒ y, (z = (y, x) âˆ§ (x . R . y))}\n\nsyntax term\"â»Â¹\" : term\n\nmacro_rules\n\n| `($term1:termâ»Â¹) => `(inv $term1)\n\n-- inverse binary relation is binary relation\n\ntheorem inv_is_rel : âˆ€ R, binary_relation R â†’ (binary_relation (Râ»Â¹)) := sorry\n\n-- inverse binary relation properties\n\ntheorem inv_pair_prop: âˆ€ R, binary_relation R â†’ âˆ€ x y, (x . R . y) â†” (y . (Râ»Â¹) . x):= sorry\n\ntheorem inv_prop : âˆ€ R, binary_relation R â†’ (Râ»Â¹)â»Â¹ = R := sorry\n\ntheorem inv_dom: âˆ€ R, binary_relation R â†’ dom (Râ»Â¹) = rng R := sorry\n\ntheorem inv_rng: âˆ€ R, binary_relation R â†’ rng (Râ»Â¹) = dom R := sorry\n\n-- P âˆ˜ Q (composition of binary relations) construction\n\nnoncomputable def composition (P Q : Set) : Set := {pr âˆˆ dom Q Ã— rng P | âˆƒ x y, (pr = (x, y)) âˆ§ âˆƒ z, (x . Q . z) âˆ§ (z . P . y)}\n\ninfix:60 (priority:=high) \" âˆ˜ \" => composition\n\n-- composition of any sets is binary relation\n\ntheorem composition_is_rel : âˆ€ P Q, binary_relation (P âˆ˜ Q) := sorry\n\n-- composition properties\n\ntheorem composition_pair_prop : âˆ€ P Q, âˆ€ x y, (x . (P âˆ˜ Q) . y) â†” âˆƒ z, (x . Q . z) âˆ§ (z . P . y) := sorry\n\ntheorem composition_pair_assoc: âˆ€ P Q R x y, (x . ((P âˆ˜ Q) âˆ˜ R) . y) â†” (x . (P âˆ˜ (Q âˆ˜ R)) . y) := sorry\n\ntheorem composition_assoc : âˆ€ P Q R, ((P âˆ˜ Q) âˆ˜ R) = (P âˆ˜ (Q âˆ˜ R)) := sorry\n\n-- inverse of composition\n\ntheorem inv_composition_pair_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (âˆ€ x y, (x . ((P âˆ˜ Q)â»Â¹) . y) â†” (x . ((Qâ»Â¹) âˆ˜ Pâ»Â¹) . y)) := sorry\n\ntheorem inv_composition_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (P âˆ˜ Q)â»Â¹ = ((Qâ»Â¹) âˆ˜ (Pâ»Â¹)) := sorry\n\n-- inverse of union\n\ntheorem inv_union_pair_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ âˆ€ x y, (x . ((P âˆª Q)â»Â¹) . y) â†” (x . (Pâ»Â¹ âˆª Qâ»Â¹) . y) := sorry\n\ntheorem inv_union_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (P âˆª Q)â»Â¹ = ((Pâ»Â¹) âˆª Qâ»Â¹) := sorry\n\n-- complement of inverse\n\ntheorem comp_inv_prop_pair : âˆ€ P A B, binary_relation_between A B P â†’ âˆ€ x y, (x . (comp A B (Pâ»Â¹)) . y) â†” (x . ((comp B A P)â»Â¹) . y) := sorry\n\ntheorem comp_inv_prop : âˆ€ P A B, binary_relation_between A B P â†’ comp A B (Pâ»Â¹) = (comp B A P)â»Â¹ := sorry\n\n-- composition of union of relations and  relation\n\ntheorem union_composition_pair_prop_right : âˆ€ P Q R, âˆ€ x y, (x . ((P âˆª Q) âˆ˜ R) . y) â†” (x . ((P âˆ˜ R) âˆª (Q âˆ˜ R)) . y) := sorry\n\ntheorem union_composition_prop_right : âˆ€ P Q R, ((P âˆª Q) âˆ˜ R) = ((P âˆ˜ R) âˆª (Q âˆ˜ R))  := sorry\n\ntheorem union_composition_pair_prop_left : âˆ€ P Q R, âˆ€ x y, (x . (P âˆ˜ (Q âˆª R)) . y) â†” (x . ((P âˆ˜ Q) âˆª (P âˆ˜ R)) . y) := sorry\n\ntheorem compostion_union_prop_left : âˆ€ P Q R, P âˆ˜ (Q âˆª R) = (P âˆ˜ Q) âˆª (P âˆ˜ R) := sorry\n\n-- subset-monotonic composition property\n\ntheorem monotonic_subset_composition_pair_right : âˆ€ P Q R, P âŠ† Q â†’ (âˆ€ x y, (x . (P âˆ˜ R) . y) â†’ (x . (Q âˆ˜ R) . y)) := sorry\n\ntheorem monotonic_subset_composition_right : âˆ€ P Q R, P âŠ† Q â†’ P âˆ˜ R âŠ† Q âˆ˜ R := sorry\n\ntheorem monotonic_subset_composition_pair_left : âˆ€ P Q R, P âŠ† Q â†’ (âˆ€ x y, (x . (R âˆ˜ P) . y) â†’ (x . (R âˆ˜ Q) . y)) := sorry\n\ntheorem monotonic_subset_composition_left : âˆ€ P Q R, P âŠ† Q â†’ R âˆ˜ P âŠ† R âˆ˜ Q := sorry\n\n-- composition of intersection of binary relations and binary relation\n\ntheorem intersect2_composition_prop_right: âˆ€ P Q R, (P âˆ© Q) âˆ˜ R âŠ† (P âˆ˜ R) âˆ© (Q âˆ˜ R) := sorry\n\ntheorem intersect2_composition_prop_left: âˆ€ P Q R, P âˆ˜ (Q âˆ© R) âŠ† (P âˆ˜ Q) âˆ© (P âˆ˜ R) := sorry\n\n-- identical binary relation\n\nnoncomputable def id_ (A : Set) : Set := {t âˆˆ (A Ã— A) | âˆƒ x : Set, t = (x, x)}\n\ntheorem id_is_rel : âˆ€ A, binary_relation (id_ A) := sorry\n\n-- id properties\n\ntheorem id_prop : âˆ€ A x y, (x . (id_ A) . y) â†’ (((x = y) âˆ§ (x âˆˆ A)) âˆ§ (y âˆˆ A)) := sorry\n\ntheorem prop_then_id : âˆ€ A, âˆ€ x âˆˆ A; (x . (id_ A) . x) := sorry\n\n-- inverse of id\n\ntheorem inv_id : âˆ€ A, ((id_ A)â»Â¹) = (id_ A) := sorry\n\n-- composition with id\n\ntheorem id_rel_composition_right : âˆ€ A B R, binary_relation_between A B R â†’ (R âˆ˜ (id_ A)) = R := sorry\n\ntheorem id_rel_composition_left : âˆ€ A B  R, binary_relation_between A B R â†’ ((id_ B) âˆ˜ R) = R := sorry\n\n-- image of a binary relation\n\nnoncomputable def rel_image (X R : Set) := {b âˆˆ rng R | âˆƒ a âˆˆ X; (a . R . b)}\n\nsyntax  term \".[\" term \"]\" : term\n\nmacro_rules\n\n  | `($R:term .[ $X:term ])  => `(rel_image $X $R)\n\n-- range is image of a domain\n\ntheorem rng_is_rel_image : âˆ€ R, binary_relation R â†’ rng R = R.[dom R] := sorry\n\n-- preimage is just image of inverse\n\n-- but it can be deined differently\n\ntheorem rel_pre_image_eq : âˆ€ Y R, binary_relation R â†’ Râ»Â¹.[Y] = {a âˆˆ dom R | âˆƒ b âˆˆ Y; (a . R . b)} := sorry\n\n-- R âŠ† A Ã— B => domain is preimage of B\n\ntheorem dom_preimage : âˆ€ A B P, binary_relation_between A B P â†’ dom P = Pâ»Â¹.[B] := sorry\n\n-- image and preimage of union of binary relations\n\ntheorem rel_image_union : âˆ€ X Y R, binary_relation R â†’ R.[X âˆª Y] = R.[X] âˆª R.[Y] := sorry\n\ntheorem rel_preimage_union : âˆ€ X Y R , binary_relation R â†’ Râ»Â¹.[X âˆª Y] = Râ»Â¹.[X] âˆª Râ»Â¹.[Y] := sorry\n\n-- subset-monotic image and preimage properties\n\ntheorem monotonic_rel_image : âˆ€ X Y R, binary_relation R â†’ X âŠ† Y â†’ R.[X] âŠ† R.[Y] := sorry\n\ntheorem monotonic_rel_preimage : âˆ€ X Y R, binary_relation R â†’ X âŠ† Y â†’ Râ»Â¹.[X] âŠ† Râ»Â¹.[Y] := sorry\n\n-- image and preimage of binary relations property\n\ntheorem rel_image_inter : âˆ€ X Y R, binary_relation R â†’ R.[X âˆ© Y] âŠ† (R.[X] âˆ© R.[Y]) := sorry\n\ntheorem rel_preimage_inter : âˆ€ X Y R, binary_relation R â†’ Râ»Â¹.[X âˆ© Y] âŠ† (Râ»Â¹.[X] âˆ© Râ»Â¹.[Y]) := sorry\n\n-- image and preimage of composition\n\ntheorem rel_image_composition : âˆ€ P Q X, (P âˆ˜ Q).[X] = P.[Q.[X]] := sorry\n\ntheorem rel_preimage_composition : âˆ€ P Q X, binary_relation P â†’ binary_relation Q â†’ (P âˆ˜ Q)â»Â¹.[X] = Qâ»Â¹.[Pâ»Â¹.[X]] := sorry"
  },
  "initial_language": "lean",
  "requirements": [
    "theorem ordered_pair_set_prop : âˆ€ a b c d, (a, b) = (c, d) â†” (a = c âˆ§ b = d)",
    "theorem ordered_pair_set_belonging: âˆ€ A B, âˆ€ a âˆˆ A; âˆ€ b âˆˆ B; (a, b) âˆˆ ğ’« (ğ’« (A âˆª B))",
    "theorem inter_pair_is_singl_fst : âˆ€ a b, â‹‚ (a, b) = {a}",
    "theorem union_pair_is_all_coords : âˆ€ a b, â‹ƒ (a, b) = {a, b}",
    "theorem coordinates_snd_corr_lemma : âˆ€ a b, {x âˆˆ â‹ƒ (a, b) | â‹ƒ (a, b) â‰  â‹‚ (a, b) â†’ x âˆ‰ â‹‚ (a, b)} = {b}",
    "theorem coordinates_fst_coor : âˆ€ a b, fst_coor (a, b) = a",
    "theorem coordinates_snd_copr : âˆ€ a b, snd_coor (a, b) = b",
    "theorem cartesian_product_is_cartesian: âˆ€ A B pr, pr âˆˆ (A Ã— B) â†” (âˆƒ x âˆˆ A; âˆƒ y âˆˆ B; pr = (x, y))",
    "theorem cartesian_product_pair_prop : âˆ€ A B a b, (a, b) âˆˆ (A Ã— B) â†” (a âˆˆ A âˆ§ b âˆˆ B)",
    "theorem binary_relation_elements_set: âˆ€ R x y, (x . R . y) â†’ (x âˆˆ â‹ƒ (â‹ƒ R) âˆ§ y âˆˆ â‹ƒ (â‹ƒ R))",
    "theorem dom_rng_rel_prop: âˆ€ R, (binary_relation R) â†’ (dom R âˆª rng R = â‹ƒ (â‹ƒ R))",
    "theorem dom_prop : âˆ€ R x, x âˆˆ dom R â†” âˆƒ y, (x . R . y)",
    "theorem rng_prop : âˆ€ R y, y âˆˆ rng R â†” âˆƒ x, (x . R . y)",
    "theorem binary_relation_prop : âˆ€ R, binary_relation R â†’ R âŠ† dom R Ã— rng R",
    "theorem prop_then_binary_relation : âˆ€ A B R, R âŠ† A Ã— B â†’ binary_relation R âˆ§ dom R âŠ† A âˆ§ rng R âŠ† B",
    "theorem rel_dom_rng_elem : âˆ€ R, binary_relation R â†’ âˆ€ x y, (x . R . y) â†’ x âˆˆ dom R âˆ§ y âˆˆ rng R",
    "theorem union2_rel_is_rel : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ binary_relation (P âˆª Q)",
    "theorem intersect2_rel_is_rel : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ binary_relation (P âˆ© Q)",
    "theorem comp_is_rel : âˆ€ A B R, binary_relation (comp A B R)",
    "theorem rel_subset : (âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (âˆ€ x y, (x . P . y) â†’ (x . Q . y)) â†’ P âŠ† Q)",
    "theorem relation_equality : (âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ ((âˆ€ x y, (x . P . y) â†” (x . Q . y)) â†’ P = Q))",
    "theorem inv_is_rel : âˆ€ R, binary_relation R â†’ (binary_relation (Râ»Â¹))",
    "theorem inv_pair_prop: âˆ€ R, binary_relation R â†’ âˆ€ x y, (x . R . y) â†” (y . (Râ»Â¹) . x)",
    "theorem inv_prop : âˆ€ R, binary_relation R â†’ (Râ»Â¹)â»Â¹ = R",
    "theorem inv_dom: âˆ€ R, binary_relation R â†’ dom (Râ»Â¹) = rng R",
    "theorem inv_rng: âˆ€ R, binary_relation R â†’ rng (Râ»Â¹) = dom R",
    "theorem composition_is_rel : âˆ€ P Q, binary_relation (P âˆ˜ Q)",
    "theorem composition_pair_prop : âˆ€ P Q, âˆ€ x y, (x . (P âˆ˜ Q) . y) â†” âˆƒ z, (x . Q . z) âˆ§ (z . P . y)",
    "theorem composition_pair_assoc: âˆ€ P Q R x y, (x . ((P âˆ˜ Q) âˆ˜ R) . y) â†” (x . (P âˆ˜ (Q âˆ˜ R)) . y)",
    "theorem composition_assoc : âˆ€ P Q R, ((P âˆ˜ Q) âˆ˜ R) = (P âˆ˜ (Q âˆ˜ R))",
    "theorem inv_composition_pair_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (âˆ€ x y, (x . ((P âˆ˜ Q)â»Â¹) . y) â†” (x . ((Qâ»Â¹) âˆ˜ Pâ»Â¹) . y))",
    "theorem inv_composition_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (P âˆ˜ Q)â»Â¹ = ((Qâ»Â¹) âˆ˜ (Pâ»Â¹))",
    "theorem inv_union_pair_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ âˆ€ x y, (x . ((P âˆª Q)â»Â¹) . y) â†” (x . (Pâ»Â¹ âˆª Qâ»Â¹) . y)",
    "theorem inv_union_prop : âˆ€ P Q, binary_relation P â†’ binary_relation Q â†’ (P âˆª Q)â»Â¹ = ((Pâ»Â¹) âˆª Qâ»Â¹)",
    "theorem comp_inv_prop_pair : âˆ€ P A B, binary_relation_between A B P â†’ âˆ€ x y, (x . (comp A B (Pâ»Â¹)) . y) â†” (x . ((comp B A P)â»Â¹) . y)",
    "theorem comp_inv_prop : âˆ€ P A B, binary_relation_between A B P â†’ comp A B (Pâ»Â¹) = (comp B A P)â»Â¹",
    "theorem union_composition_pair_prop_right : âˆ€ P Q R, âˆ€ x y, (x . ((P âˆª Q) âˆ˜ R) . y) â†” (x . ((P âˆ˜ R) âˆª (Q âˆ˜ R)) . y)",
    "theorem union_composition_prop_right : âˆ€ P Q R, ((P âˆª Q) âˆ˜ R) = ((P âˆ˜ R) âˆª (Q âˆ˜ R)) ",
    "theorem union_composition_pair_prop_left : âˆ€ P Q R, âˆ€ x y, (x . (P âˆ˜ (Q âˆª R)) . y) â†” (x . ((P âˆ˜ Q) âˆª (P âˆ˜ R)) . y)",
    "theorem compostion_union_prop_left : âˆ€ P Q R, P âˆ˜ (Q âˆª R) = (P âˆ˜ Q) âˆª (P âˆ˜ R)",
    "theorem monotonic_subset_composition_pair_right : âˆ€ P Q R, P âŠ† Q â†’ (âˆ€ x y, (x . (P âˆ˜ R) . y) â†’ (x . (Q âˆ˜ R) . y))",
    "theorem monotonic_subset_composition_right : âˆ€ P Q R, P âŠ† Q â†’ P âˆ˜ R âŠ† Q âˆ˜ R",
    "theorem monotonic_subset_composition_pair_left : âˆ€ P Q R, P âŠ† Q â†’ (âˆ€ x y, (x . (R âˆ˜ P) . y) â†’ (x . (R âˆ˜ Q) . y))",
    "theorem monotonic_subset_composition_left : âˆ€ P Q R, P âŠ† Q â†’ R âˆ˜ P âŠ† R âˆ˜ Q",
    "theorem intersect2_composition_prop_right: âˆ€ P Q R, (P âˆ© Q) âˆ˜ R âŠ† (P âˆ˜ R) âˆ© (Q âˆ˜ R)",
    "theorem intersect2_composition_prop_left: âˆ€ P Q R, P âˆ˜ (Q âˆ© R) âŠ† (P âˆ˜ Q) âˆ© (P âˆ˜ R)",
    "theorem id_is_rel : âˆ€ A, binary_relation (id_ A)",
    "theorem id_prop : âˆ€ A x y, (x . (id_ A) . y) â†’ (((x = y) âˆ§ (x âˆˆ A)) âˆ§ (y âˆˆ A))",
    "theorem prop_then_id : âˆ€ A, âˆ€ x âˆˆ A; (x . (id_ A) . x)",
    "theorem inv_id : âˆ€ A, ((id_ A)â»Â¹) = (id_ A)",
    "theorem id_rel_composition_right : âˆ€ A B R, binary_relation_between A B R â†’ (R âˆ˜ (id_ A)) = R",
    "theorem id_rel_composition_left : âˆ€ A B  R, binary_relation_between A B R â†’ ((id_ B) âˆ˜ R) = R",
    "theorem rng_is_rel_image : âˆ€ R, binary_relation R â†’ rng R = R.[dom R]",
    "theorem rel_pre_image_eq : âˆ€ Y R, binary_relation R â†’ Râ»Â¹.[Y] = {a âˆˆ dom R | âˆƒ b âˆˆ Y; (a . R . b)}",
    "theorem dom_preimage : âˆ€ A B P, binary_relation_between A B P â†’ dom P = Pâ»Â¹.[B]",
    "theorem rel_image_union : âˆ€ X Y R, binary_relation R â†’ R.[X âˆª Y] = R.[X] âˆª R.[Y]",
    "theorem rel_preimage_union : âˆ€ X Y R , binary_relation R â†’ Râ»Â¹.[X âˆª Y] = Râ»Â¹.[X] âˆª Râ»Â¹.[Y]",
    "theorem monotonic_rel_image : âˆ€ X Y R, binary_relation R â†’ X âŠ† Y â†’ R.[X] âŠ† R.[Y]",
    "theorem monotonic_rel_preimage : âˆ€ X Y R, binary_relation R â†’ X âŠ† Y â†’ Râ»Â¹.[X] âŠ† Râ»Â¹.[Y]",
    "theorem rel_image_inter : âˆ€ X Y R, binary_relation R â†’ R.[X âˆ© Y] âŠ† (R.[X] âˆ© R.[Y])",
    "theorem rel_preimage_inter : âˆ€ X Y R, binary_relation R â†’ Râ»Â¹.[X âˆ© Y] âŠ† (Râ»Â¹.[X] âˆ© Râ»Â¹.[Y])",
    "theorem rel_image_composition : âˆ€ P Q X, (P âˆ˜ Q).[X] = P.[Q.[X]]",
    "theorem rel_preimage_composition : âˆ€ P Q X, binary_relation P â†’ binary_relation Q â†’ (P âˆ˜ Q)â»Â¹.[X] = Qâ»Â¹.[Pâ»Â¹.[X]]"
  ]
}
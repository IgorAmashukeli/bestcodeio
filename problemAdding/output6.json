{
  "id": 2,
  "course": "/math/set",
  "title": "Binary relations",
  "difficulty": "Easy",
  "video_id": "y3svPgyGnLc",
  "accepted": 0,
  "submitted": 0,
  "description_text": "This is task to prove, using <b>LEAN 4</b> language. <br> Proofs should be done, by writing constructive <b>proof terms with the help of constructors and destructors</b>. <br> In each math problem you will be given a list of permitted constructors, destructors and theorems <br> To proof each theorem, remove <b>\"sorry\"</b> and replace it with <b>proof term</b>. <br> You can use following constructors and destructors: <br>In this task you allowed to use all previously discussed theorems, constructors and destructors<br>In this problem we will ordered pairs, cartesian products, binary relations, domain, range, inverse, composition, image, preimage and will prove theorems about them",
  "examples": [],
  "constraints": [],
  "note": " For reference, see this documentation: <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/title_page.html\">LEAN 4 proving</a>",
  "languages": [
    [
      "LEAN",
      "lean"
    ]
  ],
  "initial_codes": {
    "lean": "-- previous problem defitions\n\ndef exists_unique (P : α → Prop) : Prop := (∃ (x : α), P x ∧ (∀ y : α, (P y → x = y)))\n\nopen Lean TSyntax.Compat in\n\nmacro \"∃!\" xs:explicitBinders \", \" b:term : term => expandExplicitBinders ``exists_unique xs b\n\naxiom Set : Type\n\naxiom membership : Set → Set → Prop\n\ninfix:50 (priority := high) \" ∈ \" => membership\n\ninfix:50 (priority := high) \" ∉ \" => (fun (x : Set) => (fun (y : Set) => ¬ membership x y))\n\naxiom prop_to_set (P : Set → Prop) (h : ∃! x, P x) : Set\n\naxiom set_to_prop (P : Set → Prop) (h : ∃! x, P x) : P (prop_to_set P h) ∧ ∀ x, x ≠ prop_to_set P h → ¬P x\n\ndef forall_in_A (P : Set → Prop) (A : Set) : Prop := (∀ x, (x ∈ A → P x))\n\ndef exists_in_A (P : Set → Prop) (A : Set) : Prop := (∃ x, (x ∈ A ∧ P x))\n\ndef exists_uniq_in_A (P : Set → Prop) (A : Set) : Prop := (∃! x, (x ∈ A ∧ P x))\n\ndeclare_syntax_cat idents\n\nsyntax ident : idents\n\nsyntax ident idents : idents\n\nsyntax \"∀\" idents \"∈\" term \";\" term : term\n\nsyntax \"∃\" idents \"∈\" term \";\" term : term\n\nsyntax \"∃!\" idents \"∈\" term \";\" term : term\n\nmacro_rules\n\n  | `(∀ $idnt:ident ∈ $A:term; $b:term)  => `(forall_in_A (fun $idnt:ident => $b) $A)\n\n  | `(∀ $idnt:ident $idnts:idents ∈ $A:term; $b:term) => `(forall_in_A (fun $idnt:ident => (∀ $idnts:idents ∈ $A; $b)) $A)\n\n  | `(∃ $idnt:ident ∈ $A:term; $b:term)  => `(exists_in_A (fun $idnt:ident => $b) $A)\n\n  | `(∃ $idnt:ident $idnts:idents ∈ $A:term; $b:term) => `(exists_in_A (fun $idnt:ident => (∀ $idnts:idents ∈ $A; $b)) $A)\n\n  | `(∃! $idnt:ident ∈ $A:term; $b:term)  => `(exists_uniq_in_A (fun $idnt:ident => $b) $A)\n\n  | `(∃! $idnt:ident $idnts:idents ∈ $A:term; $b:term) => `(exists_uniq_in_A (fun $idnt:ident => (∀ $idnts:idents ∈ $A; $b)) $A)\n\ndef empty (A : Set) : Prop := ∀ b, (b ∉ A)\n\ndef non_empty (A : Set) : Prop := ∃ b, (b ∈ A)\n\ndef subset (A B : Set) : Prop := ∀ x ∈ A; x ∈ B\n\ndef is_successor (m n : Set) : Prop := ∀ x, (x ∈ n ↔ x ∈ m ∨ x = m)\n\ninfix:50 (priority := high) \" ⊆ \" => subset\n\naxiom exists_unique_empty : (∃! x, empty x)\n\naxiom unique_unordered_pair : (∀ a₁ a₂, ∃! C, ∀ x, (x ∈ C ↔ x = a₁ ∨ x = a₂))\n\naxiom unique_union : ∀ A, ∃! B, ∀ x, (x ∈ B ↔ ∃ y ∈ A; x ∈ y)\n\naxiom unique_specification (P : Set → Prop) : (∀ A, ∃! B, ∀ x, (x ∈ B ↔ x ∈ A ∧ P x))\n\naxiom unique_boolean : (∀ A, ∃! B, ∀ x, (x ∈ B ↔ x ⊆ A))\n\nnoncomputable def empty_set := prop_to_set empty exists_unique_empty\n\nnoncomputable def unordered_pair_set : (Set → Set → Set) := fun (a₁ : Set) => fun (a₂ : Set) =>\n\n  prop_to_set (fun (B) => ∀ x, (x ∈ B ↔ x = a₁ ∨ x = a₂)) (unique_unordered_pair a₁ a₂)\n\nnoncomputable def singleton_set : (Set → Set) := fun (a) => unordered_pair_set a a\n\nnoncomputable def union_set : (Set → Set) := fun (A) => prop_to_set (fun (B) => ∀ x, (x ∈ B ↔ ∃ y ∈ A; x ∈ y)) (unique_union A)\n\nnoncomputable def specification_set (P : Set → Prop) : (Set → Set) :=\n\n  fun (A) => prop_to_set (fun (B) => (∀ x, x ∈ B ↔ x ∈ A ∧ P x)) (unique_specification P A)\n\nnotation (priority := high) \"∅\" => empty_set\n\nnotation (priority := high) \"{\" a₁ \", \" a₂ \"}\" => unordered_pair_set a₁ a₂\n\nnotation (priority := high) \"{\" a \"}\" => singleton_set a\n\nnotation (priority := high) \"⋃\" => union_set\n\nsyntax \"{\" ident \"∈\" term \"|\" term \"}\" : term\n\nmacro_rules\n\n  | `({ $x:ident ∈ $A:term | $property:term })  => `(specification_set (fun ($x) => $property) $A)\n\nnoncomputable def union_2sets (A B : Set) := ⋃ {A, B}\n\ninfix:60 (priority:=high) \" ∪ \" => union_2sets\n\nnoncomputable def intersect_2sets (A B : Set) := {x ∈ A | x ∈ B}\n\ninfix:60 (priority:=high) \" ∩ \" => intersect_2sets\n\nnoncomputable def difference (A B : Set) := {x ∈ A | x ∉ B}\n\ninfix:60 (priority:=high) \" \\\\ \" => difference\n\nnoncomputable def symmetric_difference (A B : Set) := (A \\ B) ∪ (B \\ A)\n\ninfix:60 (priority:=high) \" △ \" => symmetric_difference\n\nnoncomputable def intersection_set : Set → Set := fun (A) => {x ∈ ⋃ A | ∀ y ∈ A; x ∈ y}\n\nnotation (priority := high) \"⋂\" => intersection_set\n\ndeclare_syntax_cat set_comprehension\n\nsyntax term \"; \" set_comprehension : set_comprehension\n\nsyntax term : set_comprehension\n\nsyntax \"{\" set_comprehension \"}\" : term\n\nmacro_rules\n\n| `({$term1:term; $term2:term}) => `(unordered_pair_set $term1:term $term2:term)\n\n| `({$elem:term; $rest:set_comprehension}) => `({$rest:set_comprehension} ∪ {$elem:term})\n\nnoncomputable def boolean_func_sym : Set → Set :=\n\n  fun (A : Set) => prop_to_set (fun (B : Set) => ∀ x, (x ∈ B ↔ x ⊆ A)) (unique_boolean A)\n\nnotation (priority := high) \"𝒫\" => boolean_func_sym\n\n-- (a₁, a₂) (ordered pair) construction\n\nnoncomputable def ordered_pair_set (a b : Set) := {{a}, {a, b}}\n\nnotation (priority := high) \"(\" a₁ \", \" a₂ \")\" => ordered_pair_set a₁ a₂\n\n-- ordered pair main property\n\ntheorem ordered_pair_set_prop : ∀ a b c d, (a, b) = (c, d) ↔ (a = c ∧ b = d) := sorry\n\n-- set, where ordered pair \"lives\"\n\ntheorem ordered_pair_set_belonging: ∀ A B, ∀ a ∈ A; ∀ b ∈ B; (a, b) ∈ 𝒫 (𝒫 (A ∪ B)) := sorry\n\n-- interesting ways to deconstruct ordered pairs\n\ntheorem inter_pair_is_singl_fst : ∀ a b, ⋂ (a, b) = {a} := sorry\n\ntheorem union_pair_is_all_coords : ∀ a b, ⋃ (a, b) = {a, b} := sorry\n\ntheorem coordinates_snd_corr_lemma : ∀ a b, {x ∈ ⋃ (a, b) | ⋃ (a, b) ≠ ⋂ (a, b) → x ∉ ⋂ (a, b)} = {b} := sorry\n\n-- first coordinate and second coordinate projectors\n\nnoncomputable def fst_coor (A : Set) : Set := ⋃ (⋂ A)\n\nnoncomputable def snd_coor (A : Set) : Set := ⋃ ({x ∈ ⋃ A | ⋃ A ≠ ⋂ A → x ∉ ⋂ A})\n\n-- ordered pair projectors main property\n\ntheorem coordinates_fst_coor : ∀ a b, fst_coor (a, b) = a := sorry\n\ntheorem coordinates_snd_copr : ∀ a b, snd_coor (a, b) = b := sorry\n\n-- A × B (cartesian product) construction\n\nnoncomputable def cartesian_product (A : Set) (B : Set) : Set := {z ∈ 𝒫 (𝒫 (A ∪ B)) | ∃ x ∈ A; ∃ y ∈ B; z = (x, y)}\n\ninfix:60 (priority:=high) \" × \" => cartesian_product\n\n-- cartesian product main property\n\ntheorem cartesian_product_is_cartesian: ∀ A B pr, pr ∈ (A × B) ↔ (∃ x ∈ A; ∃ y ∈ B; pr = (x, y)) := sorry\n\n-- cartesian product main property in terms of ordered pairs\n\ntheorem cartesian_product_pair_prop : ∀ A B a b, (a, b) ∈ (A × B) ↔ (a ∈ A ∧ b ∈ B) := sorry\n\n-- tuple construction\n\n-- ⁅a⁆, ⁅a, b⁆, ⁅a, b, c⁆, ⁅a, b, c, d⁆, ...\n\ndeclare_syntax_cat pair_comprehension\n\nsyntax  pair_comprehension \"; \" term : pair_comprehension\n\nsyntax term : pair_comprehension\n\nsyntax \"⁅\" pair_comprehension \"⁆\" : term\n\nmacro_rules\n\n| `(⁅ $term1:term⁆) => `($term1)\n\n| `(⁅ $term1:term; $term2:term⁆) => `(ordered_pair_set $term1 $term2)\n\n| `(⁅ $rest:pair_comprehension; $elem:term⁆) => `(ordered_pair_set ⁅$rest:pair_comprehension⁆ $elem:term)\n\n-- binary relation property\n\nnoncomputable def binary_relation (R : Set) : Prop := ∀ z ∈ R; ∃ a, ∃ b, z = (a, b)\n\n-- write (x . P . y) istead of (x, y) ∈ P\n\nmacro_rules\n\n| `(($x:term . $P:term . $y:term)) => `(($x, $y) ∈ $P)\n\n-- set, where first and second coordinates of pairs in binary relation \"live\"\n\ntheorem binary_relation_elements_set: ∀ R x y, (x . R . y) → (x ∈ ⋃ (⋃ R) ∧ y ∈ ⋃ (⋃ R)) := sorry\n\n-- domain and range of binary relation\n\nnoncomputable def dom (R : Set) := {x ∈ ⋃ (⋃ R) | ∃ y, (x . R . y)}\n\nnoncomputable def rng (R : Set) := {y ∈ ⋃ (⋃ R) | ∃ x, (x . R . y)}\n\n-- for binary relation R, U (U R) is actually domain ∪ range\n\ntheorem dom_rng_rel_prop: ∀ R, (binary_relation R) → (dom R ∪ rng R = ⋃ (⋃ R)) := sorry\n\n-- main domain property\n\ntheorem dom_prop : ∀ R x, x ∈ dom R ↔ ∃ y, (x . R . y) := sorry\n\n-- main range property\n\ntheorem rng_prop : ∀ R y, y ∈ rng R ↔ ∃ x, (x . R . y) := sorry\n\n-- each binary relation is a subset of domain × range.\n\ntheorem binary_relation_prop : ∀ R, binary_relation R → R ⊆ dom R × rng R := sorry\n\n-- each subset of cartesian product is binary relation with domain and range properties\n\ntheorem prop_then_binary_relation : ∀ A B R, R ⊆ A × B → binary_relation R ∧ dom R ⊆ A ∧ rng R ⊆ B := sorry\n\n-- another domain and range property\n\ntheorem rel_dom_rng_elem : ∀ R, binary_relation R → ∀ x y, (x . R . y) → x ∈ dom R ∧ y ∈ rng R := sorry\n\n-- union and intersection of binary relation is binary relation\n\ntheorem union2_rel_is_rel : ∀ P Q, binary_relation P → binary_relation Q → binary_relation (P ∪ Q) := sorry\n\ntheorem intersect2_rel_is_rel : ∀ P Q, binary_relation P → binary_relation Q → binary_relation (P ∩ Q) := sorry\n\n-- binary relation, implemented as a cartesian product subset\n\nnoncomputable def binary_relation_between (A B R : Set) : Prop := R ⊆ A × B\n\nnoncomputable def binary_relation_on (A R : Set) : Prop := R ⊆ A × A\n\n-- cartesian complement of any set is a binary relation\n\nnoncomputable def comp (A B R : Set) : Set := (A × B) \\ R\n\ntheorem comp_is_rel : ∀ A B R, binary_relation (comp A B R) := sorry\n\n-- property, enough for subset of binary relation\n\ntheorem rel_subset : (∀ P Q, binary_relation P → binary_relation Q → (∀ x y, (x . P . y) → (x . Q . y)) → P ⊆ Q) := sorry\n\n-- property, enough for equality of binary relation\n\ntheorem relation_equality : (∀ P Q, binary_relation P → binary_relation Q → ((∀ x y, (x . P . y) ↔ (x . Q . y)) → P = Q)) := sorry\n\n-- R⁻¹ (inverse binary relation) construction\n\nnoncomputable def inv (R : Set) : Set := {z ∈ rng R × dom R | ∃ x, ∃ y, (z = (y, x) ∧ (x . R . y))}\n\nsyntax term\"⁻¹\" : term\n\nmacro_rules\n\n| `($term1:term⁻¹) => `(inv $term1)\n\n-- inverse binary relation is binary relation\n\ntheorem inv_is_rel : ∀ R, binary_relation R → (binary_relation (R⁻¹)) := sorry\n\n-- inverse binary relation properties\n\ntheorem inv_pair_prop: ∀ R, binary_relation R → ∀ x y, (x . R . y) ↔ (y . (R⁻¹) . x):= sorry\n\ntheorem inv_prop : ∀ R, binary_relation R → (R⁻¹)⁻¹ = R := sorry\n\ntheorem inv_dom: ∀ R, binary_relation R → dom (R⁻¹) = rng R := sorry\n\ntheorem inv_rng: ∀ R, binary_relation R → rng (R⁻¹) = dom R := sorry\n\n-- P ∘ Q (composition of binary relations) construction\n\nnoncomputable def composition (P Q : Set) : Set := {pr ∈ dom Q × rng P | ∃ x y, (pr = (x, y)) ∧ ∃ z, (x . Q . z) ∧ (z . P . y)}\n\ninfix:60 (priority:=high) \" ∘ \" => composition\n\n-- composition of any sets is binary relation\n\ntheorem composition_is_rel : ∀ P Q, binary_relation (P ∘ Q) := sorry\n\n-- composition properties\n\ntheorem composition_pair_prop : ∀ P Q, ∀ x y, (x . (P ∘ Q) . y) ↔ ∃ z, (x . Q . z) ∧ (z . P . y) := sorry\n\ntheorem composition_pair_assoc: ∀ P Q R x y, (x . ((P ∘ Q) ∘ R) . y) ↔ (x . (P ∘ (Q ∘ R)) . y) := sorry\n\ntheorem composition_assoc : ∀ P Q R, ((P ∘ Q) ∘ R) = (P ∘ (Q ∘ R)) := sorry\n\n-- inverse of composition\n\ntheorem inv_composition_pair_prop : ∀ P Q, binary_relation P → binary_relation Q → (∀ x y, (x . ((P ∘ Q)⁻¹) . y) ↔ (x . ((Q⁻¹) ∘ P⁻¹) . y)) := sorry\n\ntheorem inv_composition_prop : ∀ P Q, binary_relation P → binary_relation Q → (P ∘ Q)⁻¹ = ((Q⁻¹) ∘ (P⁻¹)) := sorry\n\n-- inverse of union\n\ntheorem inv_union_pair_prop : ∀ P Q, binary_relation P → binary_relation Q → ∀ x y, (x . ((P ∪ Q)⁻¹) . y) ↔ (x . (P⁻¹ ∪ Q⁻¹) . y) := sorry\n\ntheorem inv_union_prop : ∀ P Q, binary_relation P → binary_relation Q → (P ∪ Q)⁻¹ = ((P⁻¹) ∪ Q⁻¹) := sorry\n\n-- complement of inverse\n\ntheorem comp_inv_prop_pair : ∀ P A B, binary_relation_between A B P → ∀ x y, (x . (comp A B (P⁻¹)) . y) ↔ (x . ((comp B A P)⁻¹) . y) := sorry\n\ntheorem comp_inv_prop : ∀ P A B, binary_relation_between A B P → comp A B (P⁻¹) = (comp B A P)⁻¹ := sorry\n\n-- composition of union of relations and  relation\n\ntheorem union_composition_pair_prop_right : ∀ P Q R, ∀ x y, (x . ((P ∪ Q) ∘ R) . y) ↔ (x . ((P ∘ R) ∪ (Q ∘ R)) . y) := sorry\n\ntheorem union_composition_prop_right : ∀ P Q R, ((P ∪ Q) ∘ R) = ((P ∘ R) ∪ (Q ∘ R))  := sorry\n\ntheorem union_composition_pair_prop_left : ∀ P Q R, ∀ x y, (x . (P ∘ (Q ∪ R)) . y) ↔ (x . ((P ∘ Q) ∪ (P ∘ R)) . y) := sorry\n\ntheorem compostion_union_prop_left : ∀ P Q R, P ∘ (Q ∪ R) = (P ∘ Q) ∪ (P ∘ R) := sorry\n\n-- subset-monotonic composition property\n\ntheorem monotonic_subset_composition_pair_right : ∀ P Q R, P ⊆ Q → (∀ x y, (x . (P ∘ R) . y) → (x . (Q ∘ R) . y)) := sorry\n\ntheorem monotonic_subset_composition_right : ∀ P Q R, P ⊆ Q → P ∘ R ⊆ Q ∘ R := sorry\n\ntheorem monotonic_subset_composition_pair_left : ∀ P Q R, P ⊆ Q → (∀ x y, (x . (R ∘ P) . y) → (x . (R ∘ Q) . y)) := sorry\n\ntheorem monotonic_subset_composition_left : ∀ P Q R, P ⊆ Q → R ∘ P ⊆ R ∘ Q := sorry\n\n-- composition of intersection of binary relations and binary relation\n\ntheorem intersect2_composition_prop_right: ∀ P Q R, (P ∩ Q) ∘ R ⊆ (P ∘ R) ∩ (Q ∘ R) := sorry\n\ntheorem intersect2_composition_prop_left: ∀ P Q R, P ∘ (Q ∩ R) ⊆ (P ∘ Q) ∩ (P ∘ R) := sorry\n\n-- identical binary relation\n\nnoncomputable def id_ (A : Set) : Set := {t ∈ (A × A) | ∃ x : Set, t = (x, x)}\n\ntheorem id_is_rel : ∀ A, binary_relation (id_ A) := sorry\n\n-- id properties\n\ntheorem id_prop : ∀ A x y, (x . (id_ A) . y) → (((x = y) ∧ (x ∈ A)) ∧ (y ∈ A)) := sorry\n\ntheorem prop_then_id : ∀ A, ∀ x ∈ A; (x . (id_ A) . x) := sorry\n\n-- inverse of id\n\ntheorem inv_id : ∀ A, ((id_ A)⁻¹) = (id_ A) := sorry\n\n-- composition with id\n\ntheorem id_rel_composition_right : ∀ A B R, binary_relation_between A B R → (R ∘ (id_ A)) = R := sorry\n\ntheorem id_rel_composition_left : ∀ A B  R, binary_relation_between A B R → ((id_ B) ∘ R) = R := sorry\n\n-- image of a binary relation\n\nnoncomputable def rel_image (X R : Set) := {b ∈ rng R | ∃ a ∈ X; (a . R . b)}\n\nsyntax  term \".[\" term \"]\" : term\n\nmacro_rules\n\n  | `($R:term .[ $X:term ])  => `(rel_image $X $R)\n\n-- range is image of a domain\n\ntheorem rng_is_rel_image : ∀ R, binary_relation R → rng R = R.[dom R] := sorry\n\n-- preimage is just image of inverse\n\n-- but it can be deined differently\n\ntheorem rel_pre_image_eq : ∀ Y R, binary_relation R → R⁻¹.[Y] = {a ∈ dom R | ∃ b ∈ Y; (a . R . b)} := sorry\n\n-- R ⊆ A × B => domain is preimage of B\n\ntheorem dom_preimage : ∀ A B P, binary_relation_between A B P → dom P = P⁻¹.[B] := sorry\n\n-- image and preimage of union of binary relations\n\ntheorem rel_image_union : ∀ X Y R, binary_relation R → R.[X ∪ Y] = R.[X] ∪ R.[Y] := sorry\n\ntheorem rel_preimage_union : ∀ X Y R , binary_relation R → R⁻¹.[X ∪ Y] = R⁻¹.[X] ∪ R⁻¹.[Y] := sorry\n\n-- subset-monotic image and preimage properties\n\ntheorem monotonic_rel_image : ∀ X Y R, binary_relation R → X ⊆ Y → R.[X] ⊆ R.[Y] := sorry\n\ntheorem monotonic_rel_preimage : ∀ X Y R, binary_relation R → X ⊆ Y → R⁻¹.[X] ⊆ R⁻¹.[Y] := sorry\n\n-- image and preimage of binary relations property\n\ntheorem rel_image_inter : ∀ X Y R, binary_relation R → R.[X ∩ Y] ⊆ (R.[X] ∩ R.[Y]) := sorry\n\ntheorem rel_preimage_inter : ∀ X Y R, binary_relation R → R⁻¹.[X ∩ Y] ⊆ (R⁻¹.[X] ∩ R⁻¹.[Y]) := sorry\n\n-- image and preimage of composition\n\ntheorem rel_image_composition : ∀ P Q X, (P ∘ Q).[X] = P.[Q.[X]] := sorry\n\ntheorem rel_preimage_composition : ∀ P Q X, binary_relation P → binary_relation Q → (P ∘ Q)⁻¹.[X] = Q⁻¹.[P⁻¹.[X]] := sorry"
  },
  "initial_language": "lean",
  "requirements": [
    "theorem ordered_pair_set_prop : ∀ a b c d, (a, b) = (c, d) ↔ (a = c ∧ b = d)",
    "theorem ordered_pair_set_belonging: ∀ A B, ∀ a ∈ A; ∀ b ∈ B; (a, b) ∈ 𝒫 (𝒫 (A ∪ B))",
    "theorem inter_pair_is_singl_fst : ∀ a b, ⋂ (a, b) = {a}",
    "theorem union_pair_is_all_coords : ∀ a b, ⋃ (a, b) = {a, b}",
    "theorem coordinates_snd_corr_lemma : ∀ a b, {x ∈ ⋃ (a, b) | ⋃ (a, b) ≠ ⋂ (a, b) → x ∉ ⋂ (a, b)} = {b}",
    "theorem coordinates_fst_coor : ∀ a b, fst_coor (a, b) = a",
    "theorem coordinates_snd_copr : ∀ a b, snd_coor (a, b) = b",
    "theorem cartesian_product_is_cartesian: ∀ A B pr, pr ∈ (A × B) ↔ (∃ x ∈ A; ∃ y ∈ B; pr = (x, y))",
    "theorem cartesian_product_pair_prop : ∀ A B a b, (a, b) ∈ (A × B) ↔ (a ∈ A ∧ b ∈ B)",
    "theorem binary_relation_elements_set: ∀ R x y, (x . R . y) → (x ∈ ⋃ (⋃ R) ∧ y ∈ ⋃ (⋃ R))",
    "theorem dom_rng_rel_prop: ∀ R, (binary_relation R) → (dom R ∪ rng R = ⋃ (⋃ R))",
    "theorem dom_prop : ∀ R x, x ∈ dom R ↔ ∃ y, (x . R . y)",
    "theorem rng_prop : ∀ R y, y ∈ rng R ↔ ∃ x, (x . R . y)",
    "theorem binary_relation_prop : ∀ R, binary_relation R → R ⊆ dom R × rng R",
    "theorem prop_then_binary_relation : ∀ A B R, R ⊆ A × B → binary_relation R ∧ dom R ⊆ A ∧ rng R ⊆ B",
    "theorem rel_dom_rng_elem : ∀ R, binary_relation R → ∀ x y, (x . R . y) → x ∈ dom R ∧ y ∈ rng R",
    "theorem union2_rel_is_rel : ∀ P Q, binary_relation P → binary_relation Q → binary_relation (P ∪ Q)",
    "theorem intersect2_rel_is_rel : ∀ P Q, binary_relation P → binary_relation Q → binary_relation (P ∩ Q)",
    "theorem comp_is_rel : ∀ A B R, binary_relation (comp A B R)",
    "theorem rel_subset : (∀ P Q, binary_relation P → binary_relation Q → (∀ x y, (x . P . y) → (x . Q . y)) → P ⊆ Q)",
    "theorem relation_equality : (∀ P Q, binary_relation P → binary_relation Q → ((∀ x y, (x . P . y) ↔ (x . Q . y)) → P = Q))",
    "theorem inv_is_rel : ∀ R, binary_relation R → (binary_relation (R⁻¹))",
    "theorem inv_pair_prop: ∀ R, binary_relation R → ∀ x y, (x . R . y) ↔ (y . (R⁻¹) . x)",
    "theorem inv_prop : ∀ R, binary_relation R → (R⁻¹)⁻¹ = R",
    "theorem inv_dom: ∀ R, binary_relation R → dom (R⁻¹) = rng R",
    "theorem inv_rng: ∀ R, binary_relation R → rng (R⁻¹) = dom R",
    "theorem composition_is_rel : ∀ P Q, binary_relation (P ∘ Q)",
    "theorem composition_pair_prop : ∀ P Q, ∀ x y, (x . (P ∘ Q) . y) ↔ ∃ z, (x . Q . z) ∧ (z . P . y)",
    "theorem composition_pair_assoc: ∀ P Q R x y, (x . ((P ∘ Q) ∘ R) . y) ↔ (x . (P ∘ (Q ∘ R)) . y)",
    "theorem composition_assoc : ∀ P Q R, ((P ∘ Q) ∘ R) = (P ∘ (Q ∘ R))",
    "theorem inv_composition_pair_prop : ∀ P Q, binary_relation P → binary_relation Q → (∀ x y, (x . ((P ∘ Q)⁻¹) . y) ↔ (x . ((Q⁻¹) ∘ P⁻¹) . y))",
    "theorem inv_composition_prop : ∀ P Q, binary_relation P → binary_relation Q → (P ∘ Q)⁻¹ = ((Q⁻¹) ∘ (P⁻¹))",
    "theorem inv_union_pair_prop : ∀ P Q, binary_relation P → binary_relation Q → ∀ x y, (x . ((P ∪ Q)⁻¹) . y) ↔ (x . (P⁻¹ ∪ Q⁻¹) . y)",
    "theorem inv_union_prop : ∀ P Q, binary_relation P → binary_relation Q → (P ∪ Q)⁻¹ = ((P⁻¹) ∪ Q⁻¹)",
    "theorem comp_inv_prop_pair : ∀ P A B, binary_relation_between A B P → ∀ x y, (x . (comp A B (P⁻¹)) . y) ↔ (x . ((comp B A P)⁻¹) . y)",
    "theorem comp_inv_prop : ∀ P A B, binary_relation_between A B P → comp A B (P⁻¹) = (comp B A P)⁻¹",
    "theorem union_composition_pair_prop_right : ∀ P Q R, ∀ x y, (x . ((P ∪ Q) ∘ R) . y) ↔ (x . ((P ∘ R) ∪ (Q ∘ R)) . y)",
    "theorem union_composition_prop_right : ∀ P Q R, ((P ∪ Q) ∘ R) = ((P ∘ R) ∪ (Q ∘ R)) ",
    "theorem union_composition_pair_prop_left : ∀ P Q R, ∀ x y, (x . (P ∘ (Q ∪ R)) . y) ↔ (x . ((P ∘ Q) ∪ (P ∘ R)) . y)",
    "theorem compostion_union_prop_left : ∀ P Q R, P ∘ (Q ∪ R) = (P ∘ Q) ∪ (P ∘ R)",
    "theorem monotonic_subset_composition_pair_right : ∀ P Q R, P ⊆ Q → (∀ x y, (x . (P ∘ R) . y) → (x . (Q ∘ R) . y))",
    "theorem monotonic_subset_composition_right : ∀ P Q R, P ⊆ Q → P ∘ R ⊆ Q ∘ R",
    "theorem monotonic_subset_composition_pair_left : ∀ P Q R, P ⊆ Q → (∀ x y, (x . (R ∘ P) . y) → (x . (R ∘ Q) . y))",
    "theorem monotonic_subset_composition_left : ∀ P Q R, P ⊆ Q → R ∘ P ⊆ R ∘ Q",
    "theorem intersect2_composition_prop_right: ∀ P Q R, (P ∩ Q) ∘ R ⊆ (P ∘ R) ∩ (Q ∘ R)",
    "theorem intersect2_composition_prop_left: ∀ P Q R, P ∘ (Q ∩ R) ⊆ (P ∘ Q) ∩ (P ∘ R)",
    "theorem id_is_rel : ∀ A, binary_relation (id_ A)",
    "theorem id_prop : ∀ A x y, (x . (id_ A) . y) → (((x = y) ∧ (x ∈ A)) ∧ (y ∈ A))",
    "theorem prop_then_id : ∀ A, ∀ x ∈ A; (x . (id_ A) . x)",
    "theorem inv_id : ∀ A, ((id_ A)⁻¹) = (id_ A)",
    "theorem id_rel_composition_right : ∀ A B R, binary_relation_between A B R → (R ∘ (id_ A)) = R",
    "theorem id_rel_composition_left : ∀ A B  R, binary_relation_between A B R → ((id_ B) ∘ R) = R",
    "theorem rng_is_rel_image : ∀ R, binary_relation R → rng R = R.[dom R]",
    "theorem rel_pre_image_eq : ∀ Y R, binary_relation R → R⁻¹.[Y] = {a ∈ dom R | ∃ b ∈ Y; (a . R . b)}",
    "theorem dom_preimage : ∀ A B P, binary_relation_between A B P → dom P = P⁻¹.[B]",
    "theorem rel_image_union : ∀ X Y R, binary_relation R → R.[X ∪ Y] = R.[X] ∪ R.[Y]",
    "theorem rel_preimage_union : ∀ X Y R , binary_relation R → R⁻¹.[X ∪ Y] = R⁻¹.[X] ∪ R⁻¹.[Y]",
    "theorem monotonic_rel_image : ∀ X Y R, binary_relation R → X ⊆ Y → R.[X] ⊆ R.[Y]",
    "theorem monotonic_rel_preimage : ∀ X Y R, binary_relation R → X ⊆ Y → R⁻¹.[X] ⊆ R⁻¹.[Y]",
    "theorem rel_image_inter : ∀ X Y R, binary_relation R → R.[X ∩ Y] ⊆ (R.[X] ∩ R.[Y])",
    "theorem rel_preimage_inter : ∀ X Y R, binary_relation R → R⁻¹.[X ∩ Y] ⊆ (R⁻¹.[X] ∩ R⁻¹.[Y])",
    "theorem rel_image_composition : ∀ P Q X, (P ∘ Q).[X] = P.[Q.[X]]",
    "theorem rel_preimage_composition : ∀ P Q X, binary_relation P → binary_relation Q → (P ∘ Q)⁻¹.[X] = Q⁻¹.[P⁻¹.[X]]"
  ]
}